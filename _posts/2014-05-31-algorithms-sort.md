---
layout: post
title: 算法导论笔记(2)--排序算法总结
description: ""
category: "alogorithms"
tags: [sort，alogorithms]
---
{% include JB/setup %}

本文主要介绍几种解决如下排序问题的算法

* 输入：n个数的一个序列 `<a₁，a₂，...，aₙ>`
* 输出：输入序列的一个排列 `<a₁'，a₂'，...，aₙ'>`，满足`a₁'<=a₂'<=...<=aₙ'`

##Index
* [插入排序（Indortion sort)](#Indortion sort)
* [归并排序(Merge sort)](#Merge sort)
* [冒泡排序(Bubble sort)](#Bubble sort)
* [堆排序(Heap sort)](#Heap sort)
* [快速排序(Quick sort)](#Quick sort)
* [计数排序(Counting sort)](#Counting sort)
* [基数排序(Radix sort)](#Radix sort)
* [桶排序(Bucket sort)](#Bucket sort)

## <span id="Indortion sort">插入排序（Indortion sort)</span>

插入排序就是每一步都将一个待排序的数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。

###伪代码：

对于插入排序，我们将其伪代码过程命名为INSERTION-SORT，其中参数是一个数组A[1..N]，包含长度为n的要排序的一个序列，在代码中，A的元素的数目n用A.length表示(下同).

![](/images/algo2-1.png)

###示例：

`A<5，2，4，6，1，3>`

![](/images/algo2-2.png)

下标j指出正要被插入的数据，在for循环（循环变量为j)的每次迭代的开始，包含数组元素A[1..j-1]的子数组构成了当前排序好的数据，剩余的子数组[j+1...n]对应于未排序的数据。事实上，元素A[1..j-1]就是原来在位置1到j-1上的数组，但现在已按序排列。

该算法的运行时间是执行每条语句的运行时间之和。在排序算法中，若输入数组已反向排序，即按递减序排序好，则导致最坏情况。需要进行INSERTION-SORT的运行时间为T(n)=O(n²)

## <span id="Merge sort">归并排序(Merge sort)</span>    

归并排序算法完全遵循前一章中提到的分治模式，直观上其操作如下：

- 分解：分解待排序的n个元素的序列成各具n/2个元素的两个子序列
- 解决：使用归并排序递归的排序两个子序列
- 合并：合并两个已排序的子序列以产生已排序的答案。

当待排序的长度为1时，递归“开始回升”，在这种情况下不要做任何工作，因为长度为1的每个序列都已排好序。

###伪代码：

归并排序算法的关键操作是“合并”步骤中两个已排序序列的合并。我们通过MERGE(A，p，q，r)来完成合并，其中A是一个数组，p，q，r是数组下标，满足p<=q<r。MERGE过程将两个已经排好序的子数组归并为一个。每次比较两个子数组中最小的数据(由于子数组已排序，所以该操作仅需Θ(1)时间），将较小的数据放入合并数组中，当两个数组中的元素全部取完时，即将两个子数组合并完毕。过程MERGE需要Θ(n)的时间，其中n=r-p+1是待合并元素的总数。

在伪代码中，为每个数组中添加了一个哨兵，它包含一个特殊的值，用于简化代码，这里使用∞作为哨兵值。

![](/images/algo2-3.png)

下面我们将过程MERGE作为归并排序算法中的一个子程序来使用。下面过程MERGE-SORT(A，p，r)排序子数组A[p...r]中的元素。若p>=r，则该子数组最多有一个元素，所以已经排序好了。否则，分解步骤简单地计算下一个下标q，将A[p..r]分成两个子数组A[p..q]和A[q+1..r]，前者包含⌈n/2⌉个元素，后则包含⌊n/2⌋个元素。

![](/images/algo2-4.png)

为了排序整个序列A=`<A₁，A₂，...Aₙ>`，我们执行初始调用MERGE-SORT(A，1，A.length)，这里A.length=n

###示例：

`A=<5，2，4，7，1，3，2，6>`

![](/images/algo2-5.png)

归并排序将规模为n的问题分解为两个规模为n/2的子问题，在合并操作中需要Θ(n)的时间，不难分析出递归排序的最坏情况运行时间T(n)=2T(n/2)+Θ(n)。应用主定理，可知，T(n)为Θ(nlgn)

## <span id="Bubble sort">冒泡排序(Bubble sort)</span>

冒泡排序是一种流行但低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素，这样一趟过去以后，最小的数字被交换到了第一位，然后再从头开始进行两两交换比较，直到第二位时结束.

###伪代码

![](/images/algo2-6.png)

###示例：

`A=<5，2，4，7，1>`

i=1：<5，2，4，7，1> --> <5，2，4，1，7> --> <5，2，1，4，7> --> <5，1，2，4，7> --> <1，5，2，4，7>

i=2: <1，5，2，4，7> --> <1，2，5，4，7>

i=3: <1，2，5，4，7> --> <1，2，4，5，7>

i=4: <1，2，4，5，7>

T(n) =Θ(n²)

## <span id="Heap sort">堆排序(Heap sort)</span>

堆排序引入了一种算法设计的技巧，使用一种我们称为"堆"的数据结构来进行信息管理。我们使用的堆不是垃圾收集存储，指的是堆数据结构。

二叉堆是一个数组，它可以被堪称一个近似的完全二叉树。树上的每一个结点对应数组中的一个元素。除了最底层外，该树是充满的，而且是从左到右填充。表示堆的数组A包括两个属性：A.length通常给出数组元素的个数，A.heap-size表示有多少个堆元素存储在该数组中。也就是说，A[1..A.length]可能都存有数据，但只有A[1..A.heap-size]中存放的是堆的有效元素。这里0<=A.heap-size<=A.length。树的根节点是A[1]，这样给定一个节点的下标i，我们很容易计算得到它的父结点、左孩子和右孩子的下标：

- PARENT(i) return ⌊i/2⌋
- LEFT(i) return 2i
- RIGHT(i) return 2i+1

![](/images/algo2-7.png)

二叉堆可以分为两种形式：最大堆和最小堆。在最大堆中，除了根以外的所有结点i都要满足：A[PARENT(i)]>=A[i]。在最小堆中，除了根以外的所有结点i都要满足：A[PARENT(i)]<=A[i]。最大堆中最大元素存放在根结点中，最小堆中最小元素存放在根结点中。

在堆排序算法中，我们使用的是最大堆。一个包含n个元素的堆的高度是Θ(lgn)

###维护堆的性质

MAX-HEAPIFY是用于维护最大堆性质的重要过程。它的输入为一个数组A和一个下标i，在调用MAX-HEAPIFY的时候，我们假定假定根节点为LEFT(i)和RIGHT(i)的二叉树都是最大堆，但这时A[i]有可能小于其孩子，这样就违背了最大堆的性质。MAX-HEAPIFY通过让A[i]的值在最大堆中”逐级下降“，从而使得下标i为根结点的子树重新遵循最大堆的性质。

伪代码：

![](/images/algo2-8.png)

下图显示了MAX-HEAPIFY的执行过程：

![](/images/algo2-9.png)

因为每个孩子的子树的大小最多为2n/3(最坏情况发生在树的最底层恰好半满的时候)，我们可以用下面的这个递归是刻画MAX-HEAPIFY的运行时间：

`T(N)<=T(2n/3)+Θ(1)`

根据主定理，上述递归式的解为T(n)=O(lgn)

###建堆

我们可以用自底向上的方法利用过程MAX-HEAPIFY把一个大小为n=A.length的数组转换为最大堆。由于子数组A(⌊n/2⌋+1..n)中的元素都是树的叶结点，每个叶结点都可以看成只包含一个元素的堆(即认为叶结点满足堆的性质)。过程BUILD-MAX-HEAP对树中的其他结点都调用一次MAX-HEAPIFY。

伪代码：

![](/images/algo2-10.png)

下图给出了BUILD-MAX-HEAP过程的一个例子。

![](/images/algo2-11.png)

BUILD-MAX-HEAP的时间复杂度为O(n)

###堆排序算法

初始时候，堆排序算法利用BUILD-MAX-HEAP将输入数组A[1..n]建成最大堆，其中n=A.length。因为数组中的最大元素总是在根结点A[1]中，通过把它与A[n]进行互换，我们可以让该元素放到正确的位置。这时候，如果我们从堆中去掉结点n(这一操作可以通过减少A.heap-size的值来实现)，剩余的结点中，原来根的孩子结点仍然是最大堆，而新的根结点可能会违背最大堆的性质。为了维护最大堆的性质，我们要做一次MAX-HEAPIFY调用，从而在A[1..n-1]上构造一个新的最大堆。堆排序算法会不断重复这一过程，直到堆的大小从n-1降到2.

伪代码：

![](/images/algo2-12.png)

下图给出了一个在HEAPSORT建立初始最大堆之后，堆排序操作的一个例子。

![](/images/algo2-13.png)

HEAPSORT过程的时间复杂度是O(nlgn)，因为每次调用BUILD-MAX-HEAP的时间复杂度是O(n)，而n-1次调用MAX-HEAPIFY，每次时间为O(lgn)

## <span id="Quick sort">快速排序(Quick sort)</span>

对于包含n个数的输入数组来说，快速排序是一种在最坏情况时间复杂度为Θ(n²)的排序算法。虽然最坏情况时间复杂度很差，但是快速排序通常是实际排序应用中最好的选择，因为它的平均性能非常好：它的期望时间复杂度是Θ(nlgn)，而且Θ(nlgn)中隐含的常数因子非常小，另外，它还能够进行原址排序(任何时候都只需要常数个额外的元素空间存储临时数据)，甚至在虚拟环境中也能很好地工作。

与归并排序一样，快速排序也使用分治思想下面对一个典型的子数组A[p..r]进行快速排序的三步分治过程：

- 分解：数组A[p..r]被划分为两个(可能为空)子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每个元素都小于等于A[q]，而A[q]也小于等于A[q+1..r]中的每个元素。其中，下表q也是划分过程的一部分。
- 通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序
- 因为子数组都是原址排序的，所以不需要合并操作：数组A[p..r]已经有序

###伪代码

下面的程序实现快速排序

![](/images/algo2-14.png)

为了排序一个数组A的全部元素，初始调用QUICKSORT(A，1，A.length)

算法的关键部分是PARTITION过程，它实现了对子数组A[p..r]的原址重排。

![](/images/algo2-15.png)

下图显示了PARTITION如何在一个包含8个元素的数组上进行操作的过程。

![](/images/algo2-16.png)

PARTITION总是选择一个x=A[r]作为主元，并围绕它来划分子数组A[p..r]。随着程序的执行，数组被划分为4个区域，如图所示

![](/images/algo2-17.png)

在子数组A[p..r]上，PARTITION维护了4个区域。A[p..i]区间内所有值小于等于x，A[i+1..j-1]区间内所有的值都大于x，A[r]=x。子数组A[j..r-1]中的值可能属于任何一种情况。

PARTITION在子数组A[p..r]上的时间复杂度是Θ(n)，其中n=r-p+1

###快速排序的性能

最坏情况划分:

当划分产生的两个子问题分别包含了n-1个元素和0个元素时，快速排序的最坏情况发生了。于是算法运行时间的递归式可以表示为：

`T(n)=T(n-1)+T(0)+Θ(n)=T(n-1)+Θ(n)`

从直观上看，每一层递归的代价可以被累积起来，从而得到一个算数级数，其结果为Θ(n²).因此如果在算法的每一层递归上，划分都是最大程度不平衡的，那么算法的时间复杂度就是Θ(n²).也就是说，在最坏情况下，快速排序算法的运行时间并不比插入排序更好。

最好情况划分：

在可能的最平衡的花费中，PARTITION得到的两个子问题的规模都不大于n/2。在这种情况下，快速排序的性能很好，此时，算法运行时间的递归式为：

`T(n)=2T(n/2)+Θ(n)`

根据主定理，上述递归式的解为T(n)=Θ(nlgn)

平衡的划分：

假设划分算法总是产生(9:1)的划分，此时，我们得到的快速排序时间复杂度的递归式为:

T(n)=T(9n/10)+T(n/10)+cn

这里，我们显示地写出了Θ(n)项中隐含的常数c.下图显示了这一递归调用所对应的递归树。

![](/images/algo2-18.png)

树中每一层的代价都是cn，直到在深度log₁₀ⁿ=Θ(lgn)处达到递归的边界条件时为止。之后每层代价至多为cn.递归在深度为log(10/9)ⁿ=Θ(lgn)处终止。因此。快速排序的总代价为O(nlgn).任何一种常数比例的划分都会产生深度为Θ(n)的递归树，其中每一层的时间代价都是O(n)。因此，只要划分是常数比例的，算法的运行时间总是O(nlgn)

对于平均情况的观察：

在平均情况下，PARTITION所产生的划分同时混合有”好“和”差“的划分。此时，在与PARTITION平均情况执行过程所对应的递归树中，好和差的划分是随机分布的。基于直觉，假设好和差的划分交替出现在各层上，并且好的划分是最好情况划分，而差的划分是最坏情况划分。在一个差的划分后面接着一个好的划分，这种组合产生出三个子数组，大小分别为0、(n-1)/2-1和(n-1)/2。这一组合的划分代价为Θ(n)+Θ(n-1)=Θ(n)，该代价并不比b中的更差。从直观上看，差划分的代价Θ(n-1)可以被吸收到好划分的代价Θ(n)中去，而得到的划分结果也是好的，因此，当好和差的划分交替出现时，快速排序的时间复杂度与全市好的划分是一样的，仍然是O(nlgn).

![](/images/algo2-19.png)

###快速排序的随机化版本

有时我们可以通过在算法中引入随机性，从而使得算法对于所有输入都能获得较好的期望性能。对于快速排序算法，我们采用一种称为随机采样的随机化技术。与始终采用A[r]作为主元的方法不同，随机采样是从子数组A[p..r]中随机选择一个元素作为主元。为了达到这一目的，首先将A[r]与从A[p..r]中随机选出的一个元素交换。通过对序列p，...，r的随机采样，我们可以保证主元元素x=A[r]是等概率地从子数组的r-p+1个元素中抽取的。因为主元元素是随机选取的，我们期望在平均情况下，对输入数组的划分是比较均衡的。

伪代码：

![](/images/algo2-20.png)

新的排序算法不再调用PARTITION，而是调用RANDOMIZED-PARTITION;

![](/images/algo2-21.png)

## <span id="Counting sort">计数排序(Counting sort)</span>

计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k=O(n)时，排序的运行时间为Θ(n)

计数排序的基本思想是：对每一个输入元素x，确定小于x的元素个数。利用这一信息，就可以直接把x放到它在输出数组中的位置上了。例如，如果有17个元素小于x，则x就应该在第18个输出位置上。

###伪代码

在计数排序算法的代码中，假设输入是一个数组A[1..n]，A.length=n。我们还需要两个数组;B[1..n]存放排序的输出，C[0..k]提供临时存储空间。

![](/images/algo2-22.png)

下图图示了计数排序的运行过程。在第5行运行结束时，C[i]中保存的就是等于i元素的个数，其中i=0，1，...，k。7-8行通过加总计算确定对每一个i=0，1，...，k，有多少输入元素是小于或等于i的。最后，10-12的for循环部分，把每个元素A[j]放到它在输出数组B中的正确位置上。

![](/images/algo2-23.png)

- a:第5行执行后的数组A和辅助数组C的情况
- b:第8行执行后，数组C的情况
- c-e分别表示10-12行循环体迭代一次，两次，三次之后，输出数组B和辅助数组C的情况
- f:最终排序的输出数组B


计数排序总的时间代价是Θ(n+k)，在实际工作中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。计数排序的一个重要性质就是它是稳定的:具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。

## <span id="Radix sort">基数排序(Radix sort)</span>

基数排序是一种非比较型整数排序算法，其原理是将 整数按位数切割成不同的数字，然后按每个位数分别比较。其他整数也表达字符串(比如名字或日期)和特定格式的浮点数，所以基数排序也不只能用于整数。

它是这样实现的，将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补0。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序数列。

![](/images/algo2-24.png)

###伪代码

基数排序的代码非常直观，在下面的代码中，我们假设n个d位的元素存放在数组A中，其中第1位是最低位，第d位是最高位.

![](/images/algo2-25.png)

###基数排序的时间代价分析

引理1:给定n个d位数，其中每一个位数有k个可能的取值。如果RADIX-SORT使用的稳定排序方法耗时Θ(n+k)，那么它就可以在Θ(d(n+k))时间内将这些数排好序。

引理2:给定一个b位数和任何正整数r<=b，如果RADIX-SORT使用的稳定排序算法对数据取值区间是0到k的输入进行排序耗时Θ(n+k)，那么它就可以在Θ((b/r)(n+2ʳ))时间内将这些数排好序。

引理1显而易见，d位数进行了d次迭代，每次迭代利用计数排序需要Θ(n+k)的运行时间，所以基数排序的运行时间为Θ(d(n+k))。当d为常数且k=O(n)时，基数排序具有线性的时间代价。

引理2，对于一个值r<=b，每个关键字可以看作d=⌈b/r⌉个r位数，每个数都是在0到2ʳ-1区间内的一个整数，这样就可以采用计数排序，其中k=2ʳ-1。每一轮排序花费时间为Θ(n+k)=Θ(n+2ʳ)，计数排序花费的总时间代价为Θ(d(n+2ʳ))=((b/r)(n+2ʳ))

对于给定的n和b，我们希望选择合适的r值能够最小化表达式(b/r)(n+2ʳ)

- b<⌊lgn⌋，则对于任何满足r<=b的r，都有(n+2ʳ)=Θ(n)，择r=b得到的时间代价为(b/b)(n+2ᵇ)=Θ(n)
- b>=⌊lgn⌋，选择r=⌊lgn⌋，可以得到偏差不超过常数系数范围内的最优时间代价

## <span id="Bucket sort">桶排序(Bucket sort)</span>

桶排序假设输入是由一个随机过程产生的，该过程将元素均匀、独立地分布在[0，1)区间上。平均情况下桶排序的时间代价为O(n)。

桶排序将[0，1)区间划分为n个相同大小的子区间，或称为桶。然后，将n个数分别放到各个桶中。因为输入数据是均匀、独立地分布在[0，1)区间上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。

###伪代码

在桶排序代码中，我们假设输入是一个包含n个元素的数组A，且每个元素A[i]满足0<=A[i]<=1。此外，算法还需要一个临时数组B[0..n-1]来存放链表（即桶），并假设存在一种用于维护这些链表的机制

![](/images/algo2-26.png)

下图显示了一个包含10个元素的输入数组上的桶排序过程。

![](/images/algo2-27.png)

- a:输入数组A[1..10]
- b:在算法的第8行之后，B[0..9]中的已排序链表(桶)的情况。排序好的输出是由链表B[0]，B[1]，...B[9]依次链接而成。

桶排序的期望运行时间为Θ(n)(算法导论8.4分析)

