<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>June's Blog</title>
 <link href="Localhost/atom.xml" rel="self"/>
 <link href="Localhost"/>
 <updated>2014-02-09T23:49:16+08:00</updated>
 <id>Localhost</id>
 <author>
   <name>June</name>
   <email>junevimer@gmail.com</email>
 </author>

 
 <entry>
   <title>(转)通用线程：POSIX 线程详解，第三部分</title>
   <link href="Localhost/2013/12/14/pthread3.html"/>
   <updated>2013-12-14T00:00:00+08:00</updated>
   <id>Localhost/2013/12/14/pthread3</id>
   <content type="html">&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;本文是 POSIX 线程三部曲系列的最后一部分，Daniel 将详细讨论如何使用条件变量。条件变量是 POSIX 线程结构，可以让您在遇到某些条件时“唤醒”线程。可以将它们看作是一种线程安全的信号发送。Daniel 使用目前您所学到的知识实现了一个多线程工作组应用程序，本文将围绕着这一示例而进行讨论。&lt;/p&gt;

&lt;p&gt;本文转自:&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/&quot;&gt;developWorks&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;条件变量详解&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://junewater.github.io/pthread/2013/12/14/pthread2.html&quot;&gt;前一篇文章&lt;/a&gt;结束时，我描述了一个比较特殊的难题：如果线程正在等待某个特定条件发生，它应该如何处理这种情况？它可以重复对互斥对象锁定和解锁，每次都会检查共享数据结构，以查找某个值。但这是在浪费时间和资源，而且这种繁忙查询的效率非常低。解决这个问题的最佳方法是使用 pthread_cond_wait() 调用来等待特殊条件发生。&lt;/p&gt;

&lt;p&gt;了解 pthread_cond_wait() 的作用非常重要 -- 它是 POSIX 线程信号发送系统的核心，也是最难以理解的部分。
首先，让我们考虑以下情况：线程为查看已链接列表而锁定了互斥对象，然而该列表恰巧是空的。这一特定线程什么也干不了 -- 其设计意图是从列表中除去节点，但是现在却没有节点。因此，它只能：&lt;/p&gt;

&lt;p&gt;锁定互斥对象时，线程将调用 pthread_cond_wait(&amp;amp;mycond,&amp;amp;mymutex)。pthread&lt;em&gt;cond&lt;/em&gt;wait() 调用相当复杂，因此我们每次只执行它的一个操作。&lt;/p&gt;

&lt;p&gt;pthread_cond_wait() 所做的第一件事就是同时对互斥对象解锁（于是其它线程可以修改已链接列表），并等待条件 mycond 发生（这样当 pthread_cond_wait() 接收到另一个线程的“信号”时，它将苏醒）。现在互斥对象已被解锁，其它线程可以访问和修改已链接列表，可能还会添加项。&lt;/p&gt;

&lt;p&gt;此时，pthread_cond_wait() 调用还未返回。对互斥对象解锁会立即发生，但等待条件 mycond 通常是一个阻塞操作，这意味着线程将睡眠，在它苏醒之前不会消耗 CPU 周期。这正是我们期待发生的情况。线程将一直睡眠，直到特定条件发生，在这期间不会发生任何浪费 CPU 时间的繁忙查询。从线程的角度来看，它只是在等待 pthread_cond_wait() 调用返回。&lt;/p&gt;

&lt;p&gt;现在继续说明，假设另一个线程（称作“2 号线程”）锁定了 mymutex 并对已链接列表添加了一项。在对互斥对象解锁之后，2 号线程会立即调用函数 pthread_cond_broadcast(&amp;amp;mycond)。此操作之后，2 号线程将使所有等待 mycond 条件变量的线程立即苏醒。这意味着第一个线程（仍处于 pthread_cond_wait() 调用中）现在将苏醒。&lt;/p&gt;

&lt;p&gt;现在，看一下第一个线程发生了什么。您可能会认为在 2 号线程调用 pthread_cond_broadcast(&amp;amp;mymutex) 之后，1 号线程的 pthread_cond_wait() 会立即返回。不是那样！实际上，pthread_cond_wait() 将执行最后一个操作：重新锁定 mymutex。一旦 pthread_cond_wait() 锁定了互斥对象，那么它将返回并允许 1 号线程继续执行。那时，它可以马上检查列表，查看它所感兴趣的更改&lt;/p&gt;

&lt;h2&gt;停止并回顾！&lt;/h2&gt;

&lt;p&gt;那个过程非常复杂，因此让我们先来回顾一下。第一个线程首先调用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_mutex_lock(&amp;amp;mymutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，它检查了列表。没有找到感兴趣的东西，于是它调用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_cond_wait(&amp;amp;mycond, &amp;amp;mymutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，pthread_cond_wait() 调用在返回前执行许多操作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_mutex_unlock(&amp;amp;mymutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它对 mymutex 解锁，然后进入睡眠状态，等待 mycond 以接收 POSIX 线程“信号”。一旦接收到“信号”（加引号是因为我们并不是在讨论传统的 UNIX 信号，而是来自 pthread_cond_signal() 或 pthread_cond_broadcast() 调用的信号），它就会苏醒。但 pthread_cond_wait() 没有立即返回 -- 它还要做一件事：重新锁定 mutex：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_mutex_lock(&amp;amp;mymutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pthread_cond_wait() 知道我们在查找 mymutex “背后”的变化，因此它继续操作，为我们锁定互斥对象，然后才返回。&lt;/p&gt;

&lt;h2&gt;pthread_cond_wait() 小测验&lt;/h2&gt;

&lt;p&gt;现在已回顾了 pthread_cond_wait() 调用，您应该了解了它的工作方式。应该能够叙述 pthread_cond_wait() 依次执行的所有操作。尝试一下。如果理解了 pthread_cond_wait()，其余部分就相当容易，因此请重新阅读以上部分，直到记住为止。好，读完之后，能否告诉我在调用 pthread_cond_wait() 之 前，互斥对象必须处于什么状态？pthread_cond_wait() 调用返回之后，互斥对象处于什么状态？这两个问题的答案都是“锁定”。既然已经完全理解了 pthread_cond_wait() 调用，现在来继续研究更简单的东西 -- 初始化和真正的发送信号和广播进程。到那时，我们将会对包含了多线程工作队列的 C 代码了如指掌&lt;/p&gt;

&lt;h2&gt;初始化和清除&lt;/h2&gt;

&lt;p&gt;条件变量是一个需要初始化的真实数据结构。以下就初始化的方法。首先，定义或分配一个条件变量，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_cond_t mycond;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，调用以下函数进行初始化：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_cond_init(&amp;amp;mycond,NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;瞧，初始化完成了！在释放或废弃条件变量之前，需要毁坏它，如下所示:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_cond_destroy(&amp;amp;mycond);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单吧。接着讨论 pthread_cond_wait() 调用。&lt;/p&gt;

&lt;h2&gt;等待&lt;/h2&gt;

&lt;p&gt;一旦初始化了互斥对象和条件变量，就可以等待某个条件，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_cond_wait(&amp;amp;mycond, &amp;amp;mymutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意，代码在逻辑上应该包含 mycond 和 mymutex。一个特定条件只能有一个互斥对象，而且条件变量应该表示互斥数据“内部”的一种特殊的条件更改。一个互斥对象可以用许多条件变量（例如，cond_empty、cond_full、cond_cleanup），但每个条件变量只能有一个互斥对象。&lt;/p&gt;

&lt;h2&gt;发送信号和广播&lt;/h2&gt;

&lt;p&gt;对于发送信号和广播，需要注意一点。如果线程更改某些共享数据，而且它想要唤醒所有正在等待的线程，则应使用 pthread_cond_broadcast 调用，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_cond_broadcast(&amp;amp;mycond);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在某些情况下，活动线程只需要唤醒第一个正在睡眠的线程。假设您只对队列添加了一个工作作业。那么只需要唤醒一个工作程序线程（再唤醒其它线程是不礼貌的！）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_cond_signal(&amp;amp;mycond);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此函数只唤醒一个线程。如果 POSIX 线程标准允许指定一个整数，可以让您唤醒一定数量的正在睡眠的线程，那就更完美了。但是很可惜，我没有被邀请参加会议。&lt;/p&gt;

&lt;h2&gt;工作组&lt;/h2&gt;

&lt;p&gt;我将演示如何创建多线程工作组。在这个方案中，我们创建了许多工作程序线程。每个线程都会检查 wq（“工作队列”），查看是否有需要完成的工作。如果有需要完成的工作，那么线程将从队列中除去一个节点，执行这些特定工作，然后等待新的工作到达。&lt;/p&gt;

&lt;p&gt;与此同时，主线程负责创建这些工作程序线程、将工作添加到队列，然后在它退出时收集所有工作程序线程。您将会遇到许多 C 代码，好好准备吧！&lt;/p&gt;

&lt;h2&gt;队列&lt;/h2&gt;

&lt;p&gt;需要队列是出于两个原因。首先，需要队列来保存工作作业。还需要可用于跟踪已终止线程的数据结构。还记得前几篇文章（请参阅本文结尾处的 参考资料）中，我曾提到过需要使用带有特定进程标识的 pthread_join 吗？使用“清除队列”（称作 &amp;quot;cq&amp;quot;）可以解决无法等待 任何已终止线程的问题（稍后将详细讨论这个问题）。以下是标准队列代码。将此代码保存到文件 queue.h 和 queue.c：&lt;/p&gt;

&lt;p&gt;queue.h:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    /* queue.h
    ** Copyright 2000 Daniel Robbins, Gentoo Technologies, Inc.
    ** Author: Daniel Robbins
    ** Date: 16 Jun 2000
    */
    typedef struct node {
        struct node *next;
    } node;
    typedef struct queue {
        node *head, *tail; 
    } queue;
    void queue_init(queue *myroot);
    void queue_put(queue *myroot, node *mynode);
    node *queue_get(queue *myroot);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;queue.c&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    /* queue.c
    ** Copyright 2000 Daniel Robbins, Gentoo Technologies, Inc.
    ** Author: Daniel Robbins
    ** Date: 16 Jun 2000
    **
    ** This set of queue functions was originally thread-aware.  I
    ** redesigned the code to make this set of queue routines
    ** thread-ignorant (just a generic, boring yet very fast set of queue
    ** routines).  Why the change?  Because it makes more sense to have
    ** the thread support as an optional add-on.  Consider a situation
    ** where you want to add 5 nodes to the queue.  With the
    ** thread-enabled version, each call to queue_put() would
    ** automatically lock and unlock the queue mutex 5 times -- that&amp;#39;s a
    ** lot of unnecessary overhead.  However, by moving the thread stuff
    ** out of the queue routines, the caller can lock the mutex once at
    ** the beginning, then insert 5 items, and then unlock at the end.
    ** Moving the lock/unlock code out of the queue functions allows for
    ** optimizations that aren&amp;#39;t possible otherwise.  It also makes this
    ** code useful for non-threaded applications.
    **
    ** We can easily thread-enable this data structure by using the
    ** data_control type defined in control.c and control.h.  */
    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;quot;queue.h&amp;quot;
    void queue_init(queue *myroot) {
        myroot-&amp;gt;head=NULL;
        myroot-&amp;gt;tail=NULL;
    }
    void queue_put(queue *myroot,node *mynode) {
        mynode-&amp;gt;next=NULL;
        if (myroot-&amp;gt;tail!=NULL)
            myroot-&amp;gt;tail-&amp;gt;next=mynode;
        myroot-&amp;gt;tail=mynode;
        if (myroot-&amp;gt;head==NULL)
            myroot-&amp;gt;head=mynode;
    }
    node *queue_get(queue *myroot) {
        //get from root
        node *mynode;
        mynode=myroot-&amp;gt;head;
        if (myroot-&amp;gt;head!=NULL)
            myroot-&amp;gt;head=myroot-&amp;gt;head-&amp;gt;next;
        return mynode;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;data_contr&lt;/h2&gt;

&lt;p&gt;我编写的并不是线程安全的队列例程，事实上我创建了一个“数据包装”或“控制”结构，它可以是任何线程支持的数据结构。看一下 control.h：ol 代码&lt;/p&gt;

&lt;p&gt;control.h&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    #include 
    typedef struct data_control {
        pthread_mutex_t mutex;
        pthread_cond_t cond;
        int active;
    } data_control;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在您看到了 data_control 结构定义，以下是它的视觉表示：&lt;/p&gt;

&lt;p&gt;所使用的 data_control 结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/JuneWater/Picture/raw/master/pthread3.gif&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;

&lt;p&gt;图像中的锁代表互斥对象，它允许对数据结构进行互斥访问。黄色的星代表条件变量，它可以睡眠，直到所讨论的数据结构改变为止。on/off 开关表示整数 &amp;quot;active&amp;quot;，它告诉线程此数据是否是活动的。在代码中，我使用整数 active 作为标志，告诉工作队列何时应该关闭。以下是 control.c：&lt;/p&gt;

&lt;p&gt;control.c&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    /* control.c
    ** Copyright 2000 Daniel Robbins, Gentoo Technologies, Inc.
    ** Author: Daniel Robbins
    ** Date: 16 Jun 2000
    **
    ** These routines provide an easy way to make any type of
    ** data-structure thread-aware.  Simply associate a data_control
    ** structure with the data structure (by creating a new struct, for
    ** example).  Then, simply lock and unlock the mutex, or
    ** wait/signal/broadcast on the condition variable in the data_control
    ** structure as needed.
    **
    ** data_control structs contain an int called &amp;quot;active&amp;quot;.  This int is
    ** intended to be used for a specific kind of multithreaded design,
    ** where each thread checks the state of &amp;quot;active&amp;quot; every time it locks
    ** the mutex.  If active is 0, the thread knows that instead of doing
    ** its normal routine, it should stop itself.  If active is 1, it
    ** should continue as normal.  So, by setting active to 0, a
    ** controlling thread can easily inform a thread work crew to shut
    ** down instead of processing new jobs.  Use the control_activate()
    ** and control_deactivate() functions, which will also broadcast on
    ** the data_control struct&amp;#39;s condition variable, so that all threads
    ** stuck in pthread_cond_wait() will wake up, have an opportunity to
    ** notice the change, and then terminate.
    */
    #include &amp;quot;control.h&amp;quot;
    int control_init(data_control *mycontrol) {
        int mystatus;
        if (pthread_mutex_init(&amp;amp;(mycontrol-&amp;gt;mutex),NULL))
            return 1;
        if (pthread_cond_init(&amp;amp;(mycontrol-&amp;gt;cond),NULL))
            return 1;
        mycontrol-&amp;gt;active=0;
        return 0;
    }

    int control_destroy(data_control *mycontrol) {
        int mystatus;
        if (pthread_cond_destroy(&amp;amp;(mycontrol-&amp;gt;cond)))
            return 1;
        if (pthread_cond_destroy(&amp;amp;(mycontrol-&amp;gt;cond)))
            return 1;
        mycontrol-&amp;gt;active=0;
        return 0;
    }

    int control_activate(data_control *mycontrol) {
        int mystatus;
        if (pthread_mutex_lock(&amp;amp;(mycontrol-&amp;gt;mutex)))
            return 0;
        mycontrol-&amp;gt;active=1;
        pthread_mutex_unlock(&amp;amp;(mycontrol-&amp;gt;mutex));
        pthread_cond_broadcast(&amp;amp;(mycontrol-&amp;gt;cond));
        return 1;
    }

    int control_deactivate(data_control *mycontrol) {
        int mystatus;
        if (pthread_mutex_lock(&amp;amp;(mycontrol-&amp;gt;mutex)))
            return 0;
        mycontrol-&amp;gt;active=0;
        pthread_mutex_unlock(&amp;amp;(mycontrol-&amp;gt;mutex));
        pthread_cond_broadcast(&amp;amp;(mycontrol-&amp;gt;cond));
        return 1;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;调试时间&lt;/h2&gt;

&lt;p&gt;在开始调试之前，还需要一个文件。以下是 dbug.h：&lt;/p&gt;

&lt;p&gt;dbug.h&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    #define dabort() \
    {printf(&amp;quot;Aborting at line %d in source file %s\n&amp;quot;,__LINE__,__FILE__); abort(); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此代码用于处理工作组代码中的不可纠正错误。&lt;/p&gt;

&lt;h2&gt;工作组代码&lt;/h2&gt;

&lt;p&gt;说到工作组代码，以下就是：&lt;/p&gt;

&lt;p&gt;workcrew.c&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;quot;control.h&amp;quot;
    #include &amp;quot;queue.h&amp;quot;
    #include &amp;quot;dbug.h&amp;quot;
    /* the work_queue holds tasks for the various threads to complete. */
    struct work_queue {
        data_control control;
        queue work;
    } wq;

    /* I added a job number to the work node.  Normally, the work node
       would contain additional data that needed to be processed. */
    typedef struct work_node {
        struct node *next;
        int jobnum;
    } wnode;

    /* the cleanup queue holds stopped threads.  Before a thread
       terminates, it adds itself to this list.  Since the main thread is
       waiting for changes in this list, it will then wake up and clean up
       the newly terminated thread. */
    struct cleanup_queue {
        data_control control;
        queue cleanup;
    } cq;

    /* I added a thread number (for debugging/instructional purposes) and
       a thread id to the cleanup node.  The cleanup node gets passed to
       the new thread on startup, and just before the thread stops, it
       attaches the cleanup node to the cleanup queue.  The main thread
       monitors the cleanup queue and is the one that performs the
       necessary cleanup. */
    typedef struct cleanup_node {
        struct node *next;
        int threadnum;
        pthread_t tid;
    } cnode;

    void *threadfunc(void *myarg) {
        wnode *mywork;
        cnode *mynode;
        mynode=(cnode *) myarg;
        pthread_mutex_lock(&amp;amp;wq.control.mutex);
        while (wq.control.active) {
            while (wq.work.head==NULL &amp;amp;&amp;amp; wq.control.active) {
                pthread_cond_wait(&amp;amp;wq.control.cond, &amp;amp;wq.control.mutex);
            }
            if (!wq.control.active) 
                break;
            //we got something!
            mywork=(wnode *) queue_get(&amp;amp;wq.work);
            pthread_mutex_unlock(&amp;amp;wq.control.mutex);
            //perform processing...
            printf(&amp;quot;Thread number %d processing job %d\n&amp;quot;,mynode-&amp;gt;threadnum,mywork-&amp;gt;jobnum);
            free(mywork);
            pthread_mutex_lock(&amp;amp;wq.control.mutex);
        }
        pthread_mutex_unlock(&amp;amp;wq.control.mutex);
        pthread_mutex_lock(&amp;amp;cq.control.mutex);
        queue_put(&amp;amp;cq.cleanup,(node *) mynode);
        pthread_mutex_unlock(&amp;amp;cq.control.mutex);
        pthread_cond_signal(&amp;amp;cq.control.cond);
        printf(&amp;quot;thread %d shutting down...\n&amp;quot;,mynode-&amp;gt;threadnum);
        return NULL;
    }

    #define NUM_WORKERS 4
    int numthreads;

    void join_threads(void) {
        cnode *curnode;
        printf(&amp;quot;joining threads...\n&amp;quot;);
        while (numthreads) {
            pthread_mutex_lock(&amp;amp;cq.control.mutex);
            /* below, we sleep until there really is a new cleanup node.  This
               takes care of any false wakeups... even if we break out of
               pthread_cond_wait(), we don&amp;#39;t make any assumptions that the
               condition we were waiting for is true.  */
            while (cq.cleanup.head==NULL) {
                pthread_cond_wait(&amp;amp;cq.control.cond,&amp;amp;cq.control.mutex);
            }

          /* at this point, we hold the mutex and there is an item in the
             list that we need to process.  First, we remove the node from
             the queue.  Then, we call pthread_join() on the tid stored in
             the node.  When pthread_join() returns, we have cleaned up
             after a thread.  Only then do we free() the node, decrement the
             number of additional threads we need to wait for and repeat the
             entire process, if necessary */
            curnode = (cnode *) queue_get(&amp;amp;cq.cleanup);
            pthread_mutex_unlock(&amp;amp;cq.control.mutex);
            pthread_join(curnode-&amp;gt;tid,NULL);
            printf(&amp;quot;joined with thread %d\n&amp;quot;,curnode-&amp;gt;threadnum);
            free(curnode);
            numthreads--;
        }
    }

    int create_threads(void) {
        int x;
        cnode *curnode;
        for (x=0; x&amp;lt;NUM_WORKERS; x++) {
            curnode=malloc(sizeof(cnode));
            if (!curnode)
                return 1;
            curnode-&amp;gt;threadnum=x;
            if (pthread_create(&amp;amp;curnode-&amp;gt;tid, NULL, threadfunc, (void *) curnode))
                return 1;
            printf(&amp;quot;created thread %d\n&amp;quot;,x);
            numthreads++;
        }
        return 0;
    }

    void initialize_structs(void) {
        numthreads=0;
        if (control_init(&amp;amp;wq.control))
            dabort();
        queue_init(&amp;amp;wq.work);
        if (control_init(&amp;amp;cq.control)) {
            control_destroy(&amp;amp;wq.control);
            dabort();
        }
        queue_init(&amp;amp;wq.work);
        control_activate(&amp;amp;wq.control);
    }

    void cleanup_structs(void) {
        control_destroy(&amp;amp;cq.control);
        control_destroy(&amp;amp;wq.control);
    }

    int main(void) {
        int x;
        wnode *mywork;
        initialize_structs();
        /* CREATION */

        if (create_threads()) {
            printf(&amp;quot;Error starting threads... cleaning up.\n&amp;quot;);
            join_threads();
            dabort();
        }
        pthread_mutex_lock(&amp;amp;wq.control.mutex);
        for (x=0; x&amp;lt;16000; x++) {
            mywork=malloc(sizeof(wnode));
            if (!mywork) {
                printf(&amp;quot;ouch! can&amp;#39;t malloc!\n&amp;quot;);
                break;
            }
            mywork-&amp;gt;jobnum=x;
            queue_put(&amp;amp;wq.work,(node *) mywork);
        }
        pthread_mutex_unlock(&amp;amp;wq.control.mutex);
        pthread_cond_broadcast(&amp;amp;wq.control.cond);
        printf(&amp;quot;sleeping...\n&amp;quot;);
        sleep(2);
        printf(&amp;quot;deactivating work queue...\n&amp;quot;);
        control_deactivate(&amp;amp;wq.control);
        /* CLEANUP  */
        join_threads();
        cleanup_structs();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;代码初排&lt;/h2&gt;

&lt;p&gt;现在来快速初排代码。定义的第一个结构称作 &amp;quot;wq&amp;quot;，它包含了 data_control 和队列头。data_control 结构用于仲裁对整个队列的访问，包括队列中的节点。下一步工作是定义实际的工作节点。要使代码符合本文中的示例，此处所包含的都是作业号。&lt;/p&gt;

&lt;p&gt;接着，创建清除队列。注释说明了它的工作方式。好，现在让我们跳过 threadfunc()、join_threads()、create_threads() 和 initialize_structs() 调用，直接跳到 main()。所做的第一件事就是初始化结构 -- 这包括初始化 data_controls 和队列，以及激活工作队列。&lt;/p&gt;

&lt;h2&gt;有关清除的注意事项&lt;/h2&gt;

&lt;p&gt;现在初始化线程。如果看一下 create_threads() 调用，似乎一切正常 -- 除了一件事。请注意，我们正在分配清除节点，以及初始化它的线程号和 TID 组件。我们还将清除节点作为初始自变量传递给每一个新的工作程序线程。为什么这样做？&lt;/p&gt;

&lt;p&gt;因为当某个工作程序线程退出时，它会将其清除节点连接到清除队列，然后终止。那时，主线程会在清除队列中检测到这个节点（利用条件变量），并将这个节点移出队列。因为 TID（线程标识）存储在清除节点中，所以主线程可以确切知道哪个线程已终止了。然后，主线程将调用 pthread_join(tid)，并联接适当的工作程序线程。如果没有做记录，那么主线程就需要按任意顺序联接工作程序线程，可能是按它们的创建顺序。由于线程不一定按此顺序终止，那么主线程可能会在已经联接了十个线程时，等待联接另一个线程。您能理解这种设计决策是如何使关闭代码加速的吗（尤其在使用几百个工作程序线程的情况下）？&lt;/p&gt;

&lt;h2&gt;创建工作&lt;/h2&gt;

&lt;p&gt;我们已启动了工作程序线程（它们已经完成了执行 threadfunc()，稍后将讨论此函数），现在主线程开始将工作节点插入工作队列。首先，它锁定 wq 的控制互斥对象，然后分配 16000 个工作包，将它们逐个插入队列。完成之后，将调用 pthread_cond_broadcast()，于是所有正在睡眠的线程会被唤醒，并开始执行工作。此时，主线程将睡眠两秒钟，然后释放工作队列，并通知工作程序线程终止活动。接着，主线程会调用 join_threads() 函数来清除所有工作程序线程。&lt;/p&gt;

&lt;h2&gt;threadfunc()&lt;/h2&gt;

&lt;p&gt;现在来讨论 threadfunc()，这是所有工作程序线程都要执行的代码。当工作程序线程启动时，它会立即锁定工作队列互斥对象，获取一个工作节点（如果有的话），然后对它进行处理。如果没有工作，则调用 pthread_cond_wait()。您会注意到这个调用在一个非常紧凑的 while() 循环中，这是非常重要的。当从 pthread_cond_wait() 调用中苏醒时，决不能认为条件肯定发生了 -- 它 可能发生了，也可能没有发生。如果发生了这种情况，即错误地唤醒了线程，而列表是空的，那么 while 循环将再次调用 pthread_cond_wait()。&lt;/p&gt;

&lt;p&gt;如果有一个工作节点，那么我们只打印它的作业号，释放它并退出。然而，实际代码会执行一些更实质性的操作。在 while() 循环结尾，我们锁定了互斥对象，以便检查 active 变量，以及在循环顶部检查新的工作节点。如果执行完此代码，就会发现如果 wq.control.active 是 0，while 循环就会终止，并会执行 threadfunc() 结尾处的清除代码。&lt;/p&gt;

&lt;p&gt;工作程序线程的清除代码部件非常有趣。首先，由于 pthread_cond_wait() 返回了锁定的互斥对象，它会对 work_queue 解锁。然后，它锁定清除队列，添加清除代码（包含了 TID，主线程将使用此 TID 来调用 pthread_join()），然后再对清除队列解锁。此后，它发信号给所有 cq 等待者 (pthread_cond_signal(&amp;amp;cq.control.cond))，于是主线程就知道有一个待处理的新节点。我们不使用 pthread_cond_broadcast()，因为没有这个必要 -- 只有一个线程（主线程）在等待清除队列中的新节点。当它调用 join_threads() 时，工作程序线程将打印关闭消息，然后终止，等待主线程发出的 pthread_join() 调用。&lt;/p&gt;

&lt;h2&gt;join_threads()&lt;/h2&gt;

&lt;p&gt;如果要查看关于如何使用条件变量的简单示例，请参考 join_threads() 函数。如果还有工作程序线程，join_threads() 会一直执行，等待清除队列中新的清除节点。如果有新节点，我们会将此节点移出队列、对清除队列解锁（从而使工作程序可以添加清除节点）、联接新的工作程序线程（使用存储在清除节点中的 TID）、释放清除节点、减少“现有”线程的数量，然后继续。&lt;/p&gt;

&lt;h2&gt;结束语&lt;/h2&gt;

&lt;p&gt;现在已经到了“POSIX 线程详解”系列的尾声，希望您已经准备好开始将多线程代码添加到您自己的应用程序中。有关详细信息，请参阅 参考资料部分，这部分内容还包含了本文中使用的所有源码的 tar 文件。下一个系列中再见！&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;您可以参阅本文在 developerWorks 全球站点上的&lt;a href=&quot;http://www.ibm.com/developerworks/library/l-posix3/index.html?S_TACT=105AGX52&amp;amp;S_CMP=cn-a-l&quot;&gt;英文原文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文中使用的&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/thread-3.tar.gz&quot;&gt;源码的tar文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;友好的 Linux pthread 在线帮助 (&amp;quot;man -k pthread&amp;quot;) 是极好的参考资料。&lt;/li&gt;
&lt;li&gt;如果要彻底了解 POSIX 线程，我推荐此书： &lt;a href=&quot;http://www.amazon.com/exec/obidos/ASIN/0201633922&quot;&gt;Programming with POSIX Threads&lt;/a&gt; ，David R. Butenhof (Addison-Wesley, 1997)。据证实，此书是现有最好的讨论 POSIX 线程的书籍&lt;/li&gt;
&lt;li&gt;W. Richard Stevens 撰写的 &lt;a href=&quot;http://www.barnesandnoble.com/u/borders/379003142&quot;&gt;UNIX Network Programming - Networking APIs: Sockets and XTI&lt;/a&gt; ，(Prentice Hall, 1997) 一书还涵盖了 POSIX 线程。这是一本经典著作，但它讨论线程不如上述的 Programming with POSIX Threads那样详细。&lt;/li&gt;
&lt;li&gt;请参阅 Sean Walton 撰写的有关 &lt;a href=&quot;http://www.ibiblio.org/pub/Linux/docs/faqs/Threads-FAQ/html/&quot;&gt;Linux线程&lt;/a&gt;的文档，KB7rfa &lt;/li&gt;
&lt;li&gt;请学习亚里桑那大学的 Mark Hays 编写的 POSIX 线程 &lt;a href=&quot;http://math.arizona.edu/%7Eswig/documentation/pthreads/&quot;&gt;教程&lt;/a&gt;。 &lt;/li&gt;
&lt;li&gt;请在 &lt;a href=&quot;http://hwaci.com/sw/pttcl/pttcl.html&quot;&gt;Pthreads-Tcl&lt;/a&gt; 介绍中查看对 Tcl 的更改，此更改使 Tcl 能够与 POSIX 线程一起使用。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;请参阅 &lt;a href=&quot;http://pauillac.inria.fr/%7Exleroy/linuxthreads/&quot;&gt;LinuxThreads 资料库&lt;/a&gt;。 &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pauillac.inria.fr/%7Exleroy/linuxthreads/&quot;&gt;Proolix&lt;/a&gt;是一种简单的遵从 POSIX 标准的基于 i8086+ 的操作系统。 &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;关于作者：&lt;/h2&gt;

&lt;p&gt;Daniel Robbins 居住在新墨西哥州的 Albuquerque。他是 Gentoo Technologies, Inc. 的总裁兼 CEO，Gentoo 项目的总设计师，MacMillan 出版书籍的撰稿作者，他的著作有： Caldera OpenLinux Unleashed, SuSE Linux Unleashed, 和 Samba Unleashed。Daniel 自二年级起就与计算机某些领域结下不解之缘，那时他首先接触的是 Logo 程序语言，并沉溺于 Pac-Man 游戏中。这也许就是他至今仍担任 SONY Electronic Publishing/Psygnosis 的首席图形设计师的原因所在。Daniel 喜欢与妻子 Mary 和新出生的女儿 Hadassah 一起共度时光。可通过 &lt;a href=&quot;mailto:drobbins@gentoo.org&quot;&gt;drobbins@gentoo.org&lt;/a&gt;与 Daniel 联系。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>(转)通用线程：POSIX 线程详解，第二部分</title>
   <link href="Localhost/2013/12/14/pthread2.html"/>
   <updated>2013-12-14T00:00:00+08:00</updated>
   <id>Localhost/2013/12/14/pthread2</id>
   <content type="html">&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;POSIX 线程是提高代码响应和性能的有力手段。在此三部分系列文章的第二篇中，Daniel Robbins 将说明，如何使用被称为互斥对象的灵巧小玩意，来保护线程代码中共享数据结构的完整性。&lt;/p&gt;

&lt;p&gt;本文转自:&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/&quot;&gt;developWorks&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;互斥我吧！&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://junewater.github.io/pthread/2013/12/14/pthread1.html&quot;&gt;前一篇文章&lt;/a&gt;中 ，谈到了会导致异常结果的线程代码。两个线程分别对同一个全局变量进行了二十次加一。变量的值最后应该是 40，但最终值却是 21。这是怎么回事呢？因为一个线程不停地“取消”了另一个线程执行的加一操作，所以产生这个问题。现在让我们来查看改正后的代码，它使用 互斥对象(mutex)来解决该问题：&lt;/p&gt;

&lt;p&gt;thread3.c&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    #include &amp;lt;pthread.h&amp;gt;
    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    int myglobal;
    pthread_mutex_t mymutex=PTHREAD_MUTEX_INITIALIZER;
    void *thread_function(void *arg) {
        int i,j;
        for ( i=0; i&amp;lt;20; i++) {
            pthread_mutex_lock(&amp;amp;mymutex);
            j=myglobal;
            j=j+1;
            printf(&amp;quot;.&amp;quot;);
            fflush(stdout);
            sleep(1);
            myglobal=j;
            pthread_mutex_unlock(&amp;amp;mymutex);
        }
        return NULL;
    }

    int main(void) {
        pthread_t mythread;
        int i;
        if ( pthread_create( &amp;amp;mythread, NULL, thread_function, NULL) ) {
            printf(&amp;quot;error creating thread.&amp;quot;);
            abort();
        }
        for ( i=0; i&amp;lt;20; i++) {
            pthread_mutex_lock(&amp;amp;mymutex);
            myglobal=myglobal+1;
            pthread_mutex_unlock(&amp;amp;mymutex);
            printf(&amp;quot;o&amp;quot;);
            fflush(stdout);
            sleep(1);
        }
        if ( pthread_join ( mythread, NULL ) ) {
            printf(&amp;quot;error joining thread.&amp;quot;);
            abort();
        }
        printf(&amp;quot;\nmyglobal equals %d\n&amp;quot;,myglobal);
        exit(0);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;解读一下&lt;/h2&gt;

&lt;p&gt;如果将这段代码与 前一篇文章 中给出的版本作一个比较，就会注意到增加了 pthread_mutex_lock() 和 pthread_mutex_unlock() 函数调用。在线程程序中这些调用执行了不可或缺的功能。他们提供了一种 相互排斥的方法（互斥对象即由此得名）。两个线程不能同时对同一个互斥对象加锁。
互斥对象是这样工作的。如果线程 a 试图锁定一个互斥对象，而此时线程 b 已锁定了同一个互斥对象时，线程 a 就将进入睡眠状态。一旦线程 b 释放了互斥对象（通过 pthread_mutex_unlock() 调用），线程 a 就能够锁定这个互斥对象（换句话说，线程 a 就将从 pthread_mutex_lock() 函数调用中返回，同时互斥对象被锁定）。同样地，当线程 a 正锁定互斥对象时，如果线程 c 试图锁定互斥对象的话，线程 c 也将临时进入睡眠状态。对已锁定的互斥对象上调用 pthread_mutex_lock() 的所有线程都将进入睡眠状态，这些睡眠的线程将“排队”访问这个互斥对象。
通常使用 pthread_mutex_lock() 和 pthread_mutex_unlock() 来保护数据结构。这就是说，通过线程的锁定和解锁，对于某一数据结构，确保某一时刻只能有一个线程能够访问它。可以推测到，当线程试图锁定一个未加锁的互斥对象时，POSIX 线程库将同意锁定，而不会使线程进入睡眠状态。&lt;/p&gt;

&lt;p&gt;请看这幅轻松的漫画，四个小精灵重现了最近一次 pthread_mutex_lock() 调用的一个场面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/JuneWater/Picture/raw/master/pthread2.gif&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中，锁定了互斥对象的线程能够存取复杂的数据结构，而不必担心同时会有其它线程干扰。那个数据结构实际上是“冻结”了，直到互斥对象被解锁为止。pthread_mutex_lock() 和 pthread_mutex_unlock() 函数调用，如同“在施工中”标志一样，将正在修改和读取的某一特定共享数据包围起来。这两个函数调用的作用就是警告其它线程，要它们继续睡眠并等待轮到它们对互斥对象加锁。当然，除非在 每个 对特定数据结构进行读写操作的语句前后，都分别放上 pthread_mutex_lock() 和 pthread_mutext_unlock() 调用，才会出现这种情况。&lt;/p&gt;

&lt;h2&gt;为什么要用互斥对象？&lt;/h2&gt;

&lt;p&gt;听上去很有趣，但究竟为什么要让线程睡眠呢？要知道，线程的主要优点不就是其具有独立工作、更多的时候是同时工作的能力吗？是的，确实是这样。然而，每个重要的线程程序都需要使用某些互斥对象。让我们再看一下示例程序以便理解原因所在。&lt;/p&gt;

&lt;p&gt;请看 thread_function()，循环中一开始就锁定了互斥对象，最后才将它解锁。在这个示例程序中，mymutex 用来保护 myglobal 的值。仔细查看 thread_function()，加一代码把 myglobal 复制到一个局部变量，对局部变量加一，睡眠一秒钟，在这之后才把局部变量的值传回给 myglobal。不使用互斥对象时，即使主线程在 thread_function() 线程睡眠一秒钟期间内对 myglobal 加一，thread_function() 苏醒后也会覆盖主线程所加的值。使用互斥对象能够保证这种情形不会发生。（您也许会想到，我增加了一秒钟延迟以触发不正确的结果。把局部变量的值赋给 myglobal 之前，实际上没有什么真正理由要求 thread_function() 睡眠一秒钟。）使用互斥对象的新程序产生了期望的结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    $ ./thread3
    o..o..o.o..o..o.o.o.o.o..o..o..o.ooooooo
    myglobal equals 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了进一步探索这个极为重要的概念，让我们看一看程序中进行加一操作的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    thread_function() 加一代码：
        j=myglobal;
        j=j+1;
        printf(&amp;quot;.&amp;quot;);
        fflush(stdout);
        sleep(1);
    myglobal=j;
    主线程加一代码：
        myglobal=myglobal+1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果代码是位于单线程程序中，可以预期 thread_function() 代码将完整执行。接下来才会执行主线程代码（或者是以相反的顺序执行）。在不使用互斥对象的线程程序中，代码可能（几乎是，由于调用了 sleep() 的缘故）以如下的顺序执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    thread_function() 线程        主线程
    j=myglobal;
    j=j+1;
    printf(&amp;quot;.&amp;quot;);
    fflush(stdout);
    sleep(1);                     myglobal=myglobal+1;
    myglobal=j;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当代码以此特定顺序执行时，将覆盖主线程对 myglobal 的修改。程序结束后，就将得到不正确的值。如果是在操纵指针的话，就可能产生段错误。注意到 thread_function() 线程按顺序执行了它的所有指令。看来不象是 thread_function() 有什么次序颠倒。问题是，同一时间内，另一个线程对同一数据结构进行了另一个修改。&lt;/p&gt;

&lt;h2&gt;线程内幕1&lt;/h2&gt;

&lt;p&gt;在解释如何确定在何处使用互斥对象之前，先来深入了解一下线程的内部工作机制。请看第一个例子：&lt;/p&gt;

&lt;p&gt;假设主线程将创建三个新线程：线程 a、线程 b 和线程 c。假定首先创建线程 a，然后是线程 b，最后创建线程 c。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_create( &amp;amp;thread_a, NULL, thread_function, NULL);
    pthread_create( &amp;amp;thread_b, NULL, thread_function, NULL);
    pthread_create( &amp;amp;thread_c, NULL, thread_function, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第一个 pthread_create() 调用完成后，可以假定线程 a 不是已存在就是已结束并停止。第二个 pthread_create() 调用后，主线程和线程 b 都可以假定线程 a 存在（或已停止）。&lt;/p&gt;

&lt;p&gt;然而，就在第二个 create() 调用返回后，主线程无法假定是哪一个线程（a 或 b）会首先开始运行。虽然两个线程都已存在，线程 CPU 时间片的分配取决于内核和线程库。至于谁将首先运行，并没有严格的规则。尽管线程 a 更有可能在线程 b 之前开始执行，但这并无保证。对于多处理器系统，情况更是如此。如果编写的代码假定在线程 b 开始执行之前实际上执行线程 a 的代码，那么，程序最终正确运行的概率是 99%。或者更糟糕，程序在您的机器上 100% 地正确运行，而在您客户的四处理器服务器上正确运行的概率却是零。&lt;/p&gt;

&lt;p&gt;从这个例子还可以得知，线程库保留了每个单独线程的代码执行顺序。换句话说，实际上那三个 pthread_create() 调用将按它们出现的顺序执行。从主线程上来看，所有代码都是依次执行的。有时，可以利用这一点来优化部分线程程序。例如，在上例中，线程 c 就可以假定线程 a 和线程 b 不是正在运行就是已经终止。它不必担心存在还没有创建线程 a 和线程 b 的可能性。可以使用这一逻辑来优化线程程序。&lt;/p&gt;

&lt;h2&gt;线程内幕2&lt;/h2&gt;

&lt;p&gt;现在来看另一个假想的例子。假设有许多线程，他们都正在执行下列代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    myglobal=mygloabl+1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么，是否需要在加一操作语句前后分别锁定和解锁互斥对象呢？也许有人会说“不”。编译器极有可能把上述赋值语句编译成一条机器指令。大家都知道，不可能&amp;quot;半途&amp;quot;中断一条机器指令。即使是硬件中断也不会破坏机器指令的完整性。基于以上考虑，很可能倾向于完全省略 pthread_mutex_lock() 和 pthread_mutex_unlock() 调用。不要这样做。&lt;/p&gt;

&lt;p&gt;我在说废话吗？不完全是这样。首先，不应该假定上述赋值语句一定会被编译成一条机器指令，除非亲自验证了机器代码。即使插入某些内嵌汇编语句以确保加一操作的完整执行――甚至，即使是自己动手写编译器！-- 仍然可能有问题。&lt;/p&gt;

&lt;p&gt;答案在这里。使用单条内嵌汇编操作码在单处理器系统上可能不会有什么问题。每个加一操作都将完整地进行，并且多半会得到期望的结果。但是多处理器系统则截然不同。在多 CPU 机器上，两个单独的处理器可能会在几乎同一时刻（或者，就在同一时刻）执行上述赋值语句。不要忘了，这时对内存的修改需要先从 L1 写入 L2 高速缓存、然后才写入主存。（SMP 机器并不只是增加了处理器而已；它还有用来仲裁对 RAM 存取的特殊硬件。）最终，根本无法搞清在写入主存的竞争中，哪个 CPU 将会&amp;quot;胜出&amp;quot;。要产生可预测的代码，应使用互斥对象。互斥对象将插入一道&amp;quot;内存关卡&amp;quot;，由它来确保对主存的写入按照线程锁定互斥对象的顺序进行。&lt;/p&gt;

&lt;p&gt;考虑一种以 32 位块为单位更新主存的 SMP 体系结构。如果未使用互斥对象就对一个 64 位整数进行加一操作，整数的最高 4 位字节可能来自一个 CPU，而其它 4 个字节却来自另一 CPU。糟糕吧！最糟糕的是，使用差劲的技术，您的程序在重要客户的系统上有可能不是很长时间才崩溃一次，就是早上三点钟就崩溃。David R. Butenhof 在他的《POSIX 线程编程》（请参阅本文末尾的 参考资料部分）一书中，讨论了由于未使用互斥对象而将产生的种种情况。&lt;/p&gt;

&lt;h2&gt;许多互斥对象&lt;/h2&gt;

&lt;p&gt;如果放置了过多的互斥对象，代码就没有什么并发性可言，运行起来也比单线程解决方案慢。如果放置了过少的互斥对象，代码将出现奇怪和令人尴尬的错误。幸运的是，有一个中间立场。首先，互斥对象是用于串行化存取&lt;em&gt;共享数据&lt;/em&gt;。不要对非共享数据使用互斥对象，并且，如果程序逻辑确保任何时候都只有一个线程能存取特定数据结构，那么也不要使用互斥对象。&lt;/p&gt;

&lt;p&gt;其次，如果要使用共享数据，那么在读、写共享数据时都应使用互斥对象。用 pthread_mutex_lock() 和 pthread_mutex_unlock() 把读写部分保护起来，或者在程序中不固定的地方随机使用它们。学会从一个线程的角度来审视代码，并确保程序中每一个线程对内存的观点都是一致和合适的。为了熟悉互斥对象的用法，最初可能要花好几个小时来编写代码，但是很快就会习惯并且什么也不必多想就能够正确使用它们。&lt;/p&gt;

&lt;h2&gt;使用调用：初始化&lt;/h2&gt;

&lt;p&gt;现在该来看看使用互斥对象的各种不同方法了。让我们从初始化开始。在 thread3.c 示例 中，我们使用了静态初始化方法。这需要声明一个 pthread_mutex_t 变量，并赋给它常数 PTHREAD_MUTEX_INITIALIZER：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_mutex_t mymutex=PTHREAD_MUTEX_INITIALIZER;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单吧。但是还可以动态地创建互斥对象。当代码使用 malloc() 分配一个新的互斥对象时，使用这种动态方法。此时，静态初始化方法是行不通的，并且应当使用例程 pthread_mutex_init()：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    int pthread_mutex_init( pthread_mutex_t *mymutex, const pthread_mutexattr_t *attr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如所示，pthread_mutex_init 接受一个指针作为参数以初始化为互斥对象，该指针指向一块已分配好的内存区。第二个参数，可以接受一个可选的 pthread_mutexattr_t 指针。这个结构可用来设置各种互斥对象属性。但是通常并不需要这些属性，所以正常做法是指定 NULL。&lt;/p&gt;

&lt;p&gt;一旦使用 pthread_mutex_init() 初始化了互斥对象，就应使用 pthread_mutex_destroy() 消除它。pthread_mutex_destroy() 接受一个指向 pthread_mutext_t 的指针作为参数，并释放创建互斥对象时分配给它的任何资源。请注意， pthread_mutex_destroy() 不会 释放用来存储 pthread_mutex_t 的内存。释放自己的内存完全取决于您。还必须注意一点，pthread_mutex_init() 和 pthread_mutex_destroy() 成功时都返回零。&lt;/p&gt;

&lt;h2&gt;使用调用：锁定&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_mutex_lock(pthread_mutex_t *mutex)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pthread_mutex_lock() 接受一个指向互斥对象的指针作为参数以将其锁定。如果碰巧已经锁定了互斥对象，调用者将进入睡眠状态。函数返回时，将唤醒调用者（显然）并且调用者还将保留该锁。函数调用成功时返回零，失败时返回非零的错误代码。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_mutex_unlock(pthread_mutex_t *mutex)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pthread_mutex_unlock() 与 pthread_mutex_lock() 相配合，它把线程已经加锁的互斥对象解锁。始终应该尽快对已加锁的互斥对象进行解锁（以提高性能）。并且绝对不要对您未保持锁的互斥对象进行解锁操作（否则，pthread_mutex_unlock() 调用将失败并带一个非零的 EPERM 返回值）。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    pthread_mutex_trylock(pthread_mutex_t *mutex)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当线程正在做其它事情的时候（由于互斥对象当前是锁定的），如果希望锁定互斥对象，这个调用就相当方便。调用 pthread_mutex_trylock() 时将尝试锁定互斥对象。如果互斥对象当前处于解锁状态，那么您将获得该锁并且函数将返回零。然而，如果互斥对象已锁定，这个调用也不会阻塞。当然，它会返回非零的 EBUSY 错误值。然后可以继续做其它事情，稍后再尝试锁定。&lt;/p&gt;

&lt;h2&gt;等待条件发生&lt;/h2&gt;

&lt;p&gt;互斥对象是线程程序必需的工具，但它们并非万能的。例如，如果线程正在等待共享数据内某个条件出现，那会发生什么呢？代码可以反复对互斥对象锁定和解锁，以检查值的任何变化。同时，还要快速将互斥对象解锁，以便其它线程能够进行任何必需的更改。这是一种非常可怕的方法，因为线程需要在合理的时间范围内频繁地循环检测变化。&lt;/p&gt;

&lt;p&gt;在每次检查之间，可以让调用线程短暂地进入睡眠，比如睡眠三秒钟，但是因此线程代码就无法最快作出响应。真正需要的是这样一种方法，当线程在等待满足某些条件时使线程进入睡眠状态。一旦条件满足，还需要一种方法以唤醒因等待满足特定条件而睡眠的线程。如果能够做到这一点，线程代码将是非常高效的，并且不会占用宝贵的互斥对象锁。这正是 POSIX 条件变量能做的事！&lt;/p&gt;

&lt;p&gt;而 POSIX 条件变量将是我下一篇文章的主题，其中将说明如何正确使用条件变量。到那时，您将拥有了创建复杂线程程序所需的全部资源，那些线程程序可以模拟工作人员、装配线等等。既然您已经越来越熟悉线程，我将在下一篇文章中加快进度。这样，在下一篇文章的结尾就能放上一个相对复杂的线程程序。说到等到条件产生，下次再见！&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;您可以参阅本文在 developerWorks 全球站点上的&lt;a href=&quot;http://www.ibm.com/developerworks/library/l-posix2/index.html?S_TACT=105AGX52&amp;amp;S_CMP=cn-a-l&quot;&gt;英文原文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;友好的 Linux pthread 在线帮助 (&amp;quot;man -k pthread&amp;quot;) 是极好的参考资料。&lt;/li&gt;
&lt;li&gt;如果要彻底了解 POSIX 线程，我推荐此书： &lt;a href=&quot;http://www.amazon.com/exec/obidos/ASIN/0201633922&quot;&gt;Programming with POSIX Threads&lt;/a&gt; ，David R. Butenhof (Addison-Wesley, 1997)。据证实，此书是现有最好的讨论 POSIX 线程的书籍&lt;/li&gt;
&lt;li&gt;W. Richard Stevens 撰写的 &lt;a href=&quot;http://www.barnesandnoble.com/u/borders/379003142&quot;&gt;UNIX Network Programming - Networking APIs: Sockets and XTI&lt;/a&gt; ，(Prentice Hall, 1997) 一书还涵盖了 POSIX 线程。这是一本经典著作，但它讨论线程不如上述的 Programming with POSIX Threads那样详细。&lt;/li&gt;
&lt;li&gt;请参阅 Sean Walton 撰写的有关 &lt;a href=&quot;http://www.ibiblio.org/pub/Linux/docs/faqs/Threads-FAQ/html/&quot;&gt;Linux线程&lt;/a&gt;的文档，KB7rfa &lt;/li&gt;
&lt;li&gt;请学习亚里桑那大学的 Mark Hays 编写的 POSIX 线程 &lt;a href=&quot;http://math.arizona.edu/%7Eswig/documentation/pthreads/&quot;&gt;教程&lt;/a&gt;。 &lt;/li&gt;
&lt;li&gt;请在 &lt;a href=&quot;http://hwaci.com/sw/pttcl/pttcl.html&quot;&gt;Pthreads-Tcl&lt;/a&gt; 介绍中查看对 Tcl 的更改，此更改使 Tcl 能够与 POSIX 线程一起使用。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;请参阅 &lt;a href=&quot;http://pauillac.inria.fr/%7Exleroy/linuxthreads/&quot;&gt;LinuxThreads 资料库&lt;/a&gt;。 &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pauillac.inria.fr/%7Exleroy/linuxthreads/&quot;&gt;Proolix&lt;/a&gt;是一种简单的遵从 POSIX 标准的基于 i8086+ 的操作系统。 &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;关于作者：&lt;/h2&gt;

&lt;p&gt;Daniel Robbins 居住在新墨西哥州的 Albuquerque。他是 Gentoo Technologies, Inc. 的总裁兼 CEO，Gentoo 项目的总设计师，MacMillan 出版书籍的撰稿作者，他的著作有： Caldera OpenLinux Unleashed, SuSE Linux Unleashed, 和 Samba Unleashed。Daniel 自二年级起就与计算机某些领域结下不解之缘，那时他首先接触的是 Logo 程序语言，并沉溺于 Pac-Man 游戏中。这也许就是他至今仍担任 SONY Electronic Publishing/Psygnosis 的首席图形设计师的原因所在。Daniel 喜欢与妻子 Mary 和新出生的女儿 Hadassah 一起共度时光。可通过 &lt;a href=&quot;mailto:drobbins@gentoo.org&quot;&gt;drobbins@gentoo.org&lt;/a&gt;与 Daniel 联系。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>(转)通用线程：POSIX 线程详解，第一部分</title>
   <link href="Localhost/2013/12/14/pthread1.html"/>
   <updated>2013-12-14T00:00:00+08:00</updated>
   <id>Localhost/2013/12/14/pthread1</id>
   <content type="html">&lt;h2&gt;一种支持内存共享的简捷工具&lt;/h2&gt;

&lt;p&gt;POSIX（可移植操作系统接口）线程是提高代码响应和性能的有力手段。在本系列中，Daniel Robbins 向您精确地展示在编程中如何使用线程。其中还涉及大量幕后细节，读完本系列文章，您完全可以运用 POSIX 线程创建多线程程序。&lt;/p&gt;

&lt;p&gt;本文转自：&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/&quot;&gt;developerWorks&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;线程是有趣的&lt;/h2&gt;

&lt;p&gt;了解如何正确运用线程是每一个优秀程序员必备的素质。线程类似于进程。如同进程，线程由内核按时间分片进行管理。在单处理器系统中，内核使用时间分片来模拟线程的并发执行，这种方式和进程的相同。而在多处理器系统中，如同多个进程，线程实际上一样可以并发执行。&lt;/p&gt;

&lt;p&gt;那么为什么对于大多数合作性任务，多线程比多个独立的进程更优越呢？这是因为，线程共享相同的内存空间。不同的线程可以存取内存中的同一个变量。所以，程序中的所有线程都可以读或写声明过的全局变量。如果曾用 fork() 编写过重要代码，就会认识到这个工具的重要性。为什么呢？虽然 fork() 允许创建多个进程，但它还会带来以下通信问题: 如何让多个进程相互通信，这里每个进程都有各自独立的内存空间。对这个问题没有一个简单的答案。虽然有许多不同种类的本地 IPC (进程间通信），但它们都遇到两个重要障碍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;强加了某种形式的额外内核开销，从而降低性能。&lt;/li&gt;
&lt;li&gt;对于大多数情形，IPC 不是对于代码的“自然”扩展。通常极大地增加了程序的复杂性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;双重坏事: 开销和复杂性都非好事。如果曾经为了支持 IPC 而对程序大动干戈过，那么您就会真正欣赏线程提供的简单共享内存机制。由于所有的线程都驻留在同一内存空间，POSIX 线程无需进行开销大而复杂的长距离调用。只要利用简单的同步机制，程序中所有的线程都可以读取和修改已有的数据结构。而无需将数据经由文件描述符转储或挤入紧窄的共享内存空间。仅此一个原因，就足以让您考虑应该采用单进程/多线程模式而非多进程/单线程模式。&lt;/p&gt;

&lt;h2&gt;线程是快捷的&lt;/h2&gt;

&lt;p&gt;不仅如此。线程同样还是非常快捷的。与标准fork()相比，线程带来的开销很小。内核无需单独复制进程的内存空间或文件描述符等等。这就节省了大量的 CPU 时间，使得线程创建比新进程创建快上十到一百倍。因为这一点，可以大量使用线程而无需太过于担心带来的 CPU 或内存不足。使用 fork() 时导致的大量 CPU 占用也不复存在。这表示只要在程序中有意义，通常就可以创建线程。&lt;/p&gt;

&lt;p&gt;当然，和进程一样，线程将利用多 CPU。如果软件是针对多处理器系统设计的，这就真的是一大特性（如果软件是开放源码，则最终可能在不少平台上运行）。特定类型线程程序（尤其是 CPU 密集型程序）的性能将随系统中处理器的数目几乎线性地提高。如果正在编写 CPU 非常密集型的程序，则绝对想设法在代码中使用多线程。一旦掌握了线程编码，无需使用繁琐的 IPC 和其它复杂的通信机制，就能够以全新和创造性的方法解决编码难题。所有这些特性配合在一起使得多线程编程更有趣、快速和灵活。&lt;/p&gt;

&lt;h2&gt;线程是可移植的&lt;/h2&gt;

&lt;p&gt;如果熟悉 Linux 编程，就有可能知道 __clone() 系统调用。__clone() 类似于fork()，同时也有许多线程的特性。例如，使用 __clone()，新的子进程可以有选择地共享父进程的执行环境（内存空间，文件描述符等）。这是好的一面。但 __clone() 也有不足之处。正如__clone() 在线帮助指出：&lt;/p&gt;

&lt;p&gt;“__clone 调用是特定于 Linux 平台的，不适用于实现可移植的程序。欲编写线程化应用程序（多线程控制同一内存空间），最好使用实现 POSIX 1003.1c 线程 API 的库，例如 Linux-Threads 库。参阅 pthread_create(3thr)。”
虽然 __clone() 有线程的许多特性，但它是不可移植的。当然这并不意味着代码中不能使用它。但在软件中考虑使用 __clone() 时应当权衡这一事实。值得庆幸的是，正如 __clone() 在线帮助指出，有一种更好的替代方案：POSIX 线程。如果想编写 可移植的 多线程代码，代码可运行于 Solaris、FreeBSD、Linux 和其它平台，POSIX 线程是一种当然之选。&lt;/p&gt;

&lt;h2&gt;第一个线程&lt;/h2&gt;

&lt;p&gt;下面是一个 POSIX 线程的简单示例程序：&lt;/p&gt;

&lt;p&gt;thread1:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    #include &amp;lt;pthread.h&amp;gt;
    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    void *thread_function(void *arg) {
        int i;
        for ( i=0; i&amp;lt;20; i++) {
            printf(&amp;quot;Thread says hi!\n&amp;quot;);
            sleep(1);
        }
        return NULL;
    }

    int main(void) {
        pthread_t mythread;

        if ( pthread_create( &amp;amp;mythread, NULL, thread_function, NULL) ) {
            printf(&amp;quot;error creating thread.&amp;quot;);
            abort();
        }
        if ( pthread_join ( mythread, NULL ) ) {
            printf(&amp;quot;error joining thread.&amp;quot;);
            abort();
        }
        exit(0);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要编译这个程序，只需先将程序存为 thread1.c，然后输入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    $ gcc thread1.c -o thread1 -lpthread
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行则输入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    $ ./thread1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;理解 thread1.c&lt;/h2&gt;

&lt;p&gt;thread1.c 是一个非常简单的线程程序。虽然它没有实现什么有用的功能，但可以帮助理解线程的运行机制。下面，我们一步一步地了解这个程序是干什么的。main() 中声明了变量 mythread，类型是 pthread_t。pthread_t 类型在 pthread.h 中定义，通常称为“线程 id”（缩写为 &amp;quot;tid&amp;quot;）。可以认为它是一种线程句柄。&lt;/p&gt;

&lt;p&gt;mythread 声明后（记住 mythread 只是一个 &amp;quot;tid&amp;quot;，或是将要创建的线程的句柄），调用 pthread_create 函数创建一个真实活动的线程。不要因为 pthread_create() 在 &amp;quot;if&amp;quot; 语句内而受其迷惑。由于 pthread_create() 执行成功时返回零而失败时则返回非零值，将 pthread_create() 函数调用放在 if() 语句中只是为了方便地检测失败的调用。让我们查看一下 pthread_create 参数。第一个参数 &amp;amp;mythread 是指向 mythread 的指针。第二个参数当前为 NULL，可用来定义线程的某些属性。由于缺省的线程属性是适用的，只需将该参数设为 NULL。&lt;/p&gt;

&lt;p&gt;第三个参数是新线程启动时调用的函数名。本例中，函数名为 thread_function()。当 thread_function() 返回时，新线程将终止。本例中，线程函数没有实现大的功能。它仅将 &amp;quot;Thread says hi!&amp;quot; 输出 20 次然后退出。注意 thread_function() 接受 void * 作为参数，同时返回值的类型也是 void *。这表明可以用 void * 向新线程传递任意类型的数据，新线程完成时也可返回任意类型的数据。那如何向线程传递一个任意参数？很简单。只要利用 pthread_create() 中的第四个参数。本例中，因为没有必要将任何数据传给微不足道的 thread_function()，所以将第四个参数设为 NULL。&lt;/p&gt;

&lt;p&gt;您也许已推测到，在 pthread_create() 成功返回之后，程序将包含两个线程。等一等， 两个 线程？我们不是只创建了一个线程吗？不错，我们只创建了一个进程。但是主程序同样也是一个线程。可以这样理解：如果编写的程序根本没有使用 POSIX 线程，则该程序是单线程的（这个单线程称为“主”线程）。创建一个新线程之后程序总共就有两个线程了。&lt;/p&gt;

&lt;p&gt;我想此时您至少有两个重要问题。第一个问题，新线程创建之后主线程如何运行。答案，主线程按顺序继续执行下一行程序（本例中执行 &amp;quot;if (pthread_join(...))&amp;quot;）。第二个问题，新线程结束时如何处理。答案，新线程先停止，然后作为其清理过程的一部分，等待与另一个线程合并或“连接”。&lt;/p&gt;

&lt;p&gt;现在，来看一下 pthread_join()。正如 pthread_create() 将一个线程拆分为两个， pthread_join() 将两个线程合并为一个线程。pthread_join() 的第一个参数是 tid mythread。第二个参数是指向 void 指针的指针。如果 void 指针不为 NULL，pthread_join 将线程的 void * 返回值放置在指定的位置上。由于我们不必理会 thread_function() 的返回值，所以将其设为 NULL.&lt;/p&gt;

&lt;p&gt;您会注意到 thread_function() 花了 20 秒才完成。在 thread_function() 结束很久之前，主线程就已经调用了 pthread_join()。如果发生这种情况，主线程将中断（转向睡眠）然后等待 thread_function() 完成。当 thread_function() 完成后, pthread_join() 将返回。这时程序又只有一个主线程。当程序退出时，所有新线程已经使用 pthread_join() 合并了。这就是应该如何处理在程序中创建的每个新线程的过程。如果没有合并一个新线程，则它仍然对系统的最大线程数限制不利。这意味着如果未对线程做正确的清理，最终会导致 pthread_create() 调用失败。&lt;/p&gt;

&lt;h2&gt;无父，无子&lt;/h2&gt;

&lt;p&gt;如果使用过 fork() 系统调用，可能熟悉父进程和子进程的概念。当用 fork() 创建另一个新进程时，新进程是子进程，原始进程是父进程。这创建了可能非常有用的层次关系，尤其是等待子进程终止时。例如，waitpid() 函数让当前进程等待所有子进程终止。waitpid() 用来在父进程中实现简单的清理过程。&lt;/p&gt;

&lt;p&gt;而 POSIX 线程就更有意思。您可能已经注意到我一直有意避免使用“父线程”和“子线程”的说法。这是因为 POSIX 线程中不存在这种层次关系。虽然主线程可以创建一个新线程，新线程可以创建另一个新线程，POSIX 线程标准将它们视为等同的层次。所以等待子线程退出的概念在这里没有意义。POSIX 线程标准不记录任何“家族”信息。缺少家族信息有一个主要含意：如果要等待一个线程终止，就必须将线程的 tid 传递给 pthread_join()。线程库无法为您断定 tid。&lt;/p&gt;

&lt;p&gt;对大多数开发者来说这不是个好消息，因为这会使有多个线程的程序复杂化。不过不要为此担忧。POSIX 线程标准提供了有效地管理多个线程所需要的所有工具。实际上，没有父/子关系这一事实却为在程序中使用线程开辟了更创造性的方法。例如，如果有一个线程称为线程 1，线程 1 创建了称为线程 2 的线程，则线程 1 自己没有必要调用 pthread_join() 来合并线程 2，程序中其它任一线程都可以做到。当编写大量使用线程的代码时，这就可能允许发生有趣的事情。例如，可以创建一个包含所有已停止线程的全局“死线程列表”，然后让一个专门的清理线程专等停止的线程加到列表中。这个清理线程调用 pthread_join() 将刚停止的线程与自己合并。现在，仅用一个线程就巧妙和有效地处理了全部清理。&lt;/p&gt;

&lt;h2&gt;同步漫游&lt;/h2&gt;

&lt;p&gt;现在我们来看一些代码，这些代码做了一些意想不到的事情。thread2.c 的代码如下：&lt;/p&gt;

&lt;p&gt;thread2&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    #include &amp;lt;pthread.h&amp;gt;
    #include &amp;lt;stdlib.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt;
    #include &amp;lt;stdio.h&amp;gt;
    int myglobal;
    void *thread_function(void *arg) {
        int i,j;
        for ( i=0; i&amp;lt;20; i++) {
            j=myglobal;
            j=j+1;
            printf(&amp;quot;.&amp;quot;);
            fflush(stdout);
            sleep(1);
            myglobal=j;
        }
        return NULL;
    }

    int main(void) {
        pthread_t mythread;
        int i;
        if ( pthread_create( &amp;amp;mythread, NULL, thread_function, NULL) ) {
            printf(&amp;quot;error creating thread.&amp;quot;);
            abort();
        }
        for ( i=0; i&amp;lt;20; i++) {
            myglobal=myglobal+1;
            printf(&amp;quot;o&amp;quot;);
            fflush(stdout);
            sleep(1);
        }
        if ( pthread_join ( mythread, NULL ) ) {
            printf(&amp;quot;error joining thread.&amp;quot;);
            abort();
        }
        printf(&amp;quot;\nmyglobal equals %d\n&amp;quot;,myglobal);
        exit(0);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;理解thread2.c&lt;/h2&gt;

&lt;p&gt;如同第一个程序，这个程序创建一个新线程。主线程和新线程都将全局变量 myglobal 加一 20 次。但是程序本身产生了某些意想不到的结果。编译代码请输入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    $ gcc thread2.c -o thread2 -lpthread
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行请输入：
        $ ./thread2&lt;/p&gt;

&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    $ ./thread2
    ..o.o.o.o.oo.o.o.o.o.o.o.o.o.o..o.o.o.o.o
    myglobal equals 21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常意外吧！因为 myglobal 从零开始，主线程和新线程各自对其进行了 20 次加一, 程序结束时 myglobal 值应当等于 40。由于 myglobal 输出结果为 21，这其中肯定有问题。但是究竟是什么呢？&lt;/p&gt;

&lt;p&gt;放弃吗？好，让我来解释是怎么一回事。首先查看函数 thread&lt;em&gt;function()。注意如何将 myglobal 复制到局部变量 &amp;quot;j&amp;quot; 了吗? 接着将 j 加一, 再睡眠一秒，然后到这时才将新的 j 值复制到 myglobal？这就是关键所在。设想一下，如果主线程就在新线程将 myglobal 值复制给 j 后 立即将 myglobal 加一，会发生什么？当 thread&lt;/em&gt;function() 将 j 的值写回 myglobal 时，就覆盖了主线程所做的修改。&lt;/p&gt;

&lt;p&gt;当编写线程程序时，应避免产生这种无用的副作用，否则只会浪费时间（当然，除了编写关于 POSIX 线程的文章时有用）。那么，如何才能排除这种问题呢？&lt;/p&gt;

&lt;p&gt;由于是将 myglobal 复制给 j 并且等了一秒之后才写回时产生问题，可以尝试避免使用临时局部变量并直接将 myglobal 加一。虽然这种解决方案对这个特定例子适用，但它还是不正确。如果我们对 myglobal 进行相对复杂的数学运算，而不是简单的加一，这种方法就会失效。但是为什么呢？&lt;/p&gt;

&lt;p&gt;要理解这个问题，必须记住线程是并发运行的。即使在单处理器系统上运行（内核利用时间分片模拟多任务）也是可以的，从程序员的角度，想像两个线程是同时执行的。thread2.c 出现问题是因为 thread_function() 依赖以下论据：在 myglobal 加一之前的大约一秒钟期间不会修改 myglobal。需要有些途径让一个线程在对 myglobal 做更改时通知其它线程“不要靠近”。我将在下一篇文章中讲解如何做到这一点。到时候见。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;友好的 Linux pthread 在线帮助 (&amp;quot;man -k pthread&amp;quot;) 是极好的参考资料。&lt;/li&gt;
&lt;li&gt;如果要彻底了解 POSIX 线程，我推荐此书： &lt;a href=&quot;http://www.amazon.com/exec/obidos/ASIN/0201633922&quot;&gt;Programming with POSIX Threads&lt;/a&gt; ，David R. Butenhof (Addison-Wesley, 1997)。据证实，此书是现有最好的讨论 POSIX 线程的书籍&lt;/li&gt;
&lt;li&gt;W. Richard Stevens 撰写的 &lt;a href=&quot;http://www.barnesandnoble.com/u/borders/379003142&quot;&gt;UNIX Network Programming - Networking APIs: Sockets and XTI&lt;/a&gt; ，(Prentice Hall, 1997) 一书还涵盖了 POSIX 线程。这是一本经典著作，但它讨论线程不如上述的 Programming with POSIX Threads那样详细。&lt;/li&gt;
&lt;li&gt;请参阅 Sean Walton 撰写的有关 &lt;a href=&quot;http://www.ibiblio.org/pub/Linux/docs/faqs/Threads-FAQ/html/&quot;&gt;Linux线程&lt;/a&gt;的文档，KB7rfa &lt;/li&gt;
&lt;li&gt;请学习亚里桑那大学的 Mark Hays 编写的 POSIX 线程 &lt;a href=&quot;http://math.arizona.edu/%7Eswig/documentation/pthreads/&quot;&gt;教程&lt;/a&gt;。 &lt;/li&gt;
&lt;li&gt;请在 &lt;a href=&quot;http://hwaci.com/sw/pttcl/pttcl.html&quot;&gt;Pthreads-Tcl&lt;/a&gt; 介绍中查看对 Tcl 的更改，此更改使 Tcl 能够与 POSIX 线程一起使用。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;请参阅 &lt;a href=&quot;http://pauillac.inria.fr/%7Exleroy/linuxthreads/&quot;&gt;LinuxThreads 资料库&lt;/a&gt;。 &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pauillac.inria.fr/%7Exleroy/linuxthreads/&quot;&gt;Proolix&lt;/a&gt;是一种简单的遵从 POSIX 标准的基于 i8086+ 的操作系统。 &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;关于作者：&lt;/h2&gt;

&lt;p&gt;Daniel Robbins 居住在新墨西哥州的 Albuquerque。他是 Gentoo Technologies, Inc. 的总裁兼 CEO，Gentoo 项目的总设计师，MacMillan 出版书籍的撰稿作者，他的著作有： Caldera OpenLinux Unleashed, SuSE Linux Unleashed, 和 Samba Unleashed。Daniel 自二年级起就与计算机某些领域结下不解之缘，那时他首先接触的是 Logo 程序语言，并沉溺于 Pac-Man 游戏中。这也许就是他至今仍担任 SONY Electronic Publishing/Psygnosis 的首席图形设计师的原因所在。Daniel 喜欢与妻子 Mary 和新出生的女儿 Hadassah 一起共度时光。可通过 &lt;a href=&quot;mailto:drobbins@gentoo.org&quot;&gt;drobbins@gentoo.org&lt;/a&gt;与 Daniel 联系。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Lua元表与元方法</title>
   <link href="Localhost/2013/12/13/lua-metatable.html"/>
   <updated>2013-12-13T00:00:00+08:00</updated>
   <id>Localhost/2013/12/13/lua-metatable</id>
   <content type="html">&lt;p&gt;通常，Lua中的每个值都有一套预定义的操作集合。例如将数字相加，可以连接字符串，还可以在table中插入一对key-value等。但是我们无法将两个table相加，无法对
函数作比较，也无法调用一个字符串。&lt;strong&gt;可以通过元表来修改一个值的行为，使其面对一个预定义的操作执行一个制定的操作。&lt;/strong&gt;例如，当Lua试图将两个table相加时，它
会先检查两者之一是否有元表，然后检查该元表中是否有一个叫__add的字段。如果找到了该字段，就调用该字段对应的值。这个值就是所谓的&amp;quot;元方法&amp;quot;，它应该是一个函数
，在本例中，这个函数用于计算table的和。&lt;/p&gt;

&lt;p&gt;可以使用getmetatable获取一个值的元表，也可以使用setmetatable来设置或修改任何table的元表。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    t= {}
    printf(getmetatable(t))  ---&amp;gt;nil 创建新的table时不会创建元表
    t1 = {}
    setmetatable(t,t1)      ---&amp;gt;设置t的元表为table t1
    assert(getmetatable(t)==t1) ---&amp;gt;当t的元表不为t1时将触发错误
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任何table可以作为任何值的元表而一组相关的table也可以共享一个通用的元表，元表描述它们的共同行为，一个table甚至可以作为它自己的元表，用于表述其特有的行为。&lt;/p&gt;

&lt;h2&gt;算数类的元方法&lt;/h2&gt;

&lt;p&gt;假设用table来表示集合。并且有一些函数用来计算集合的并集和交集等。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    local mt = {}   --集合的元表
    Set = {} --创建名字空间

    --根据参数列表中的值创建一个新的集合
    function Set.new(l)
        local set = {}
        setmetatable(set,mt)
        for _,v in ipairs(l) do set[v] = true end
        return set
    end


    function Set.union(a,b)
        local res = Set.new{}               
        for k in pairs(a) do res[k] = true end  --如果table a中key不为nil，则res[k]=true 
        for k in pairs(b) do res[k] = true end
        return res --返回a,b的并集
    end

    mt.__add = Set.union    --只要Lua试图将两个集合相加，就会调用Set.union函数,使用加号(+)计算两个集合的交集，
                            --需要让所有用于表示集合的table共享一个元表，并且在该元表中定义如何执行一个加法操作

    function Set.intersection(a,b)  
        local res = Set.new{}
        for k in pairs(a) do
        res[k] = b[k] --如果b中未定义k的值，则res[k]=nil
        end
        return res --返回a,b的交集
    end

    mt.__mul = Set.intersection --乘号来求集合的交集

    function Set.tostring(set)
        local l = {}
        for e in pairs(set) do
            l[#l+1] = e
        end
        return &amp;quot;{&amp;quot;..table.concat(1,&amp;quot;, &amp;quot;)..&amp;quot;}&amp;quot; --concat列出参数中指定table的数组部分从start位置到end位置的所有元素，元素间以, 隔开
    end

    function Set.print (s)
        print(Set.tostring(s))
    end

    s1 = Set.new{10,20,30,50}   --返回table s1中 s1[10]=true s2[20]=true...
    s2 = Set.new{30,1}
    print(getmetatable(s1))     --打印字符串一样，说明创建的集合属于相同的元表
    print(getmetatable(s2))

    s3 = s1+s2
    Set.print(s3)   ---&amp;gt;{1,10,20,30,50} 
    Set.print((s1+s2)*s3)   ---&amp;gt;{10, 20, 30, 50} --注意打印的格式
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;__add:加&lt;/li&gt;
&lt;li&gt;__mul:乘&lt;/li&gt;
&lt;li&gt;__sub:减&lt;/li&gt;
&lt;li&gt;__unm:相反数&lt;/li&gt;
&lt;li&gt;__div:除&lt;/li&gt;
&lt;li&gt;__mod:取模&lt;/li&gt;
&lt;li&gt;__pow:乘幂&lt;/li&gt;
&lt;li&gt;__concat:表述连接操作符的行为&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;关系类的元方法&lt;/h2&gt;

&lt;p&gt;元表还可以表示关系操作符的含义，元方法为&lt;em&gt;__eq&lt;/em&gt;(等于)，&lt;em&gt;__lt&lt;/em&gt;(小于)，&lt;em&gt;__le&lt;/em&gt;（小于等于)。与算数类的元方法不同的是，关系类的元方法不能应用于混合的类型。对于混合类型而言，关系类元方法的行为就模拟这些操作符在Lua中普通的行为。&lt;/p&gt;

&lt;h3&gt;库定义的元方法&lt;/h3&gt;

&lt;p&gt;元表也是一种常规的table，所以任何人，任何函数都可以使用它们。&lt;/p&gt;

&lt;p&gt;函数tostring示例:tostring能将各种类型的值表示为一种简单的文本格式，函数print总是调用tostring来格式化其输出。当格式化任意值时，tostring会检查该值是否有一个&lt;em&gt;__tostring&lt;/em&gt;的元方法，如果有这个元方法，tostring就用该值作为参数来调用这个元方法。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    mt.__tostring = Set.tostring
    s1 = Set.new{10,4,5}
    print(s1)   ---&amp;gt;{4,5,10}       --print调用tostring函数，进而调用Set.string
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数setmetatabe和getmetatabe会用到元表中的一个字段，用于保护元表。假设想要保护集合的元表，使用户既不能看也不能修改集合的元表。那么就需要用到字段__metatable。当设置该字段时，getmetatable就会返回这个字段的值，而setmetatable则会引发一个错误：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    mt.__metatable = &amp;quot;not your business&amp;quot;
    s1 = Set.new{}
    print(getmetatable(s1)) ---&amp;gt;not your business 想要获得集合的元表
    setmetatable(s1,{})
    stdin:1: cannot change protected metatable 引发一个错误
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;table访问的元方法&lt;/h3&gt;

&lt;p&gt;Lua提供了两种可以改变的table行为：查询table及修改table中不存在的字段&lt;/p&gt;

&lt;h4&gt;__index元方法&lt;/h4&gt;

&lt;p&gt;当访问一个table中不存在的字段时，它会促使解释器去查找一个叫&lt;em&gt;__index&lt;/em&gt;的元方法。如果没有这个元方法，那么访问结果为nil，否则，就有这个元方法来提供最终结果&lt;/p&gt;

&lt;p&gt;假设要创建一些表述窗口的table，每个table中必须表述窗口参数，例如位置、大小及主题颜色等。所有这些参数都有默认值，因此希望在创建窗口对象时可以制定那些不同于默认值的参数。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    使用构造式
    Window = {} --创建一个名字空间
    --使用默认值创建一个原型
    Window.prototype = {x=0, y=0, width=100, height=100 }
    Window.mt = {}  --创建元表
    --声明构造函数
    function Window.new(o)
        setmetatable(o,Window.mt)
        return 0
    end
    --定义__index元方法
    Window.mt.__index = function (table,key)
        return Window.prototype[key]
    end

    w=Window.new{x=10,y=20}
    print(w.width)  ---&amp;gt;100 访问w中未定义的width，返回元操作__index的返回值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当&lt;em&gt;__index&lt;/em&gt;元方法为一个函数时，Lua以table和不存在的key作为参数调用这个函数，而当它是一个table时，Lua就以相同的方式来重新访问这个table，因此，上例中&lt;em&gt;__index&lt;/em&gt;的声明可以简单地写为:&lt;em&gt;Window.mt.__index = Window.prototype&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如果不想在访问一个table时涉及到它的__index元方法，可以使用函数rawget。调用rawget(t,i)就是对table t进行一个原始的（raw）访问。&lt;/p&gt;

&lt;h4&gt;__newindex元方法&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;__newindex&lt;/em&gt;用于table的更新，&lt;em&gt;__index&lt;/em&gt;用于table的查询，当对一个table中不存在的索引赋值时，解释器就会查找&lt;em&gt;__newindex&lt;/em&gt;元方法。如果有这个元方法，解释器就调用它，而不是执行赋值。吐过这个元方法是一个table，解释器就会在此table中执行赋值，而不是对原来的table。&lt;/p&gt;

&lt;p&gt;调用raw(t,k,v)就可以不设计任何元方法而直接设置table t中与key k想关联的value v.&lt;/p&gt;

&lt;p&gt;组合使用&lt;em&gt;__index&lt;/em&gt;和&lt;em&gt;__newindex&lt;/em&gt;元方法可以实现出Lua中的一些强大功能，例如，只读的table、具有默认值的table和面向对象编程中的继承。&lt;/p&gt;

&lt;h4&gt;具有默认值的table&lt;/h4&gt;

&lt;p&gt;常规table中的任何字段默认都是nil，通过元表就可以很容易的修改这个默认值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    function setDefault (t,d)
        local mt={__index = function () return d end} --定义__inde元方法
        setmetatable(t,mt)
    end

    tab = {x=10,y=20}
    print(tab.x,tab.z)  ---&amp;gt;10 nil
    setDefault(tab,0)   
    print(tab.x,tab.z)  ---&amp;gt;10 0
    --调用setDefault后，任何对tab中不存在字段的访问都将调用它的__index元方法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setDefault函数为所有需要默认值的table创建了一个新的元表，如果准备创建很多需要默认值的table，这种方法的开销或许就比较大了。由于元表中默认值d是与元方法关联在一起的，所以setDefault无法为所有table都使用同一个元表。如果让具有不同默认值的table都使用同一个元表，那么就需要将每个元表的默认值都存放在table本身中。可以使用一个额外的字段来保存默认值。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    --如果不担心名字冲突的话，可以使用&amp;quot;___&amp;quot;这样的key作为额外的字段：
    local mt = {__index = function (t) return t.___ end}
        t.___ = d
        setmetatable(t,mt)
    end

    --如果担心名字冲突，那么报确保一个特殊key的唯一性也很容易，
    --只需创建一个新的table，并用它作为key即可
    local key = {}  --唯一的key
    local mt = {__index = function(t) return t[k] end}
    function setDefault (t,d)
        t[k] = d
        setmetatablt(t,mt)
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;跟踪table的访问&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;__index&lt;/em&gt;和&lt;em&gt;__newindex&lt;/em&gt;都是在table中没有所需访问的index时才发挥作用的。因此，只有将一个table保持为空，才有可能捕捉到所有对它的访问。为了监视一个table的所有访问，就应该为真正的table创建一个代理。这个代理就是以个空的table，其中&lt;em&gt;__index&lt;/em&gt;和&lt;em&gt;__newindex&lt;/em&gt;元方法可用于跟踪所有的访问，并将访问重定向到原来的table上。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    t={}    --原来的table

    local _t =t     --保持对原table的一个私有访问
    t = {}  --创建代理

    --创建代理
    local mt = {
        __index = function(t,k)
        print(&amp;quot;*access to element &amp;quot; .. tostring(k))
        return -t[k]    --访问原来的table
        end,

    __newindex = function(t,k,v)
        print(&amp;quot;*update of element &amp;quot; .. tostring(k) .. &amp;quot; to &amp;quot; .. tostring(v)
    _t[k] = v   --更新原来的table
    end
    }
    setmetatablt(t,mt)

    t[2] = &amp;quot;hello&amp;quot;
    ---&amp;gt;*update of element 2 to hello
    print(t[2])
    *access to element 2
    hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例方法存在一个问题，就是无法遍历原来的table。函数pairs只能操作代理table,而无法访问原来的table.&lt;/p&gt;

&lt;p&gt;如果想要同时监视几个table，无需为每个table创建不同的元表。相反，只要以某种形式将每个代理与其原table关联起来，并且所有代理都共享一个公共的元表。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    local index = {}    --创建私有索引

    local mt ={         --创建元表
        __index = function (t,k)    
        print(&amp;quot;*access to element &amp;quot; .. tostring(k))
        return t[index][k]  -- 访问原来的table
        end,

        __newindex = function(t,k,v)
            print(&amp;quot;*update to element &amp;quot; .. tostring(k) .. &amp;quot; to &amp;quot; .. tostring(v)
        t[index][k] = v --更新原来的table
        end
   }

    function track(t)
        local proxy = {}
        proxy[index] = t
        setmetatablt(proxy,mt)
        return proxy
    end
    现在，若要监视table t，唯一要做的就是执行t = track(t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;只读的table&lt;/h4&gt;

&lt;p&gt;实现只读的table,只要跟踪所有对table的更新操作，并引发一个错误就可以了。由于无需跟踪查询访问，所以对于&lt;em&gt;__index&lt;/em&gt;元方法可以直接使用原table来代理函数。这种做法要求每个只读代理创建一个新的元表，其中&lt;em&gt;__index&lt;/em&gt;指向原来的table&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    function readOnly (t)
        local proxy = {}
        local mt = {    --创建元表
            __index = t
            __newindex = function(t,k,v)
                error(&amp;quot;attempt to update a read-only table&amp;quot;,2)
                end
        }
        setmetatable(proxy,mt)
        return proxy
    end

    --示例
    days = readOnly{&amp;quot;Sunday&amp;quot;,&amp;quot;Monday&amp;quot;,&amp;quot;Tuesday&amp;quot;,&amp;quot;Wednesday&amp;quot;,&amp;quot;Thursday&amp;quot;,&amp;quot;Friday&amp;quot;,&amp;quot;Saturday&amp;quot;}
    --这里days为一个代理
    print(day[1])   ---&amp;gt;Sunday
    days[2] = &amp;quot;Noday&amp;quot;
    stdin:1:attempt to update a read-only table
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
 </entry>
 
 <entry>
   <title>Ubuntu12.04下Vim配置之不折腾版</title>
   <link href="Localhost/2013/12/12/vim-config.html"/>
   <updated>2013-12-12T00:00:00+08:00</updated>
   <id>Localhost/2013/12/12/vim-config</id>
   <content type="html">&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;用vim大概也有六个月了吧，用原生的大概1个月，后面各种折腾，这是第2次折腾以后的最终版本了，写篇博客记录下。&lt;/p&gt;

&lt;h2&gt;Vim基本用法&lt;/h2&gt;

&lt;p&gt;推荐：耗子的&lt;a href=&quot;http://coolshell.cn/articles/5426.html&quot;&gt;简明Vim练级攻略&lt;/a&gt; 以及《学习Vi和Vim编辑器》&lt;/p&gt;

&lt;h2&gt;Vim的安装&lt;/h2&gt;

&lt;p&gt;由于插件&lt;a href=&quot;https://github.com/Valloric/YouCompleteMe&quot;&gt;YouCompleteMe&lt;/a&gt;需要系统安装的Vim版本在7.3.584之上。而UBuntu12.04下通过&lt;code&gt;sudo apt-get install vim&lt;/code&gt;自动安装的Vim版本不满足要求，所以首先需要卸载原来的vim版本。安装最新的vim7.4版本，具体操作点&lt;a href=&quot;https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，如果你不需要YCM插件支持。可以使用系统默认安装的Vim版本.&lt;/p&gt;

&lt;p&gt;PS：安装好Vim7.4之后，在INSERT模式下，退格键(backspace)不能删除换行，也就是说不能从第二行一直按退格键到第一行，网上查找资料解决方法如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    1. vim缺省是和vi兼容的，设置成不兼容，在`.vimrc`中添加`set nocompatible`  
    2. vim的backspace有几种工作方式，默认是和vi兼容的，同样需要修改，在`.vimrc`中添加`set backspace=indent,eol,start`  
    (a) indent：如果使用了set indent等自动缩进，想用退格键将缩进字段删掉，必须设置这个选项，否则vim不响应退格  
    (b) eol：如果在INSERT模式下，在行头想通过退格键合并两行，需要设置这个选项  
    (c) start：要想删除在此次插入前的输入，需要设置这个选项  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Vim配置步骤&lt;/h2&gt;

&lt;h3&gt;用Vundle管理插件&lt;/h3&gt;

&lt;p&gt;如果不使用vundle的话（当然啦，还有其他的插件管理工具，比如pathogen），进行插件的安装，配置和管理相对会比较麻烦，曾经没使用vundle的时候我经常遇到无法安装插件以及
卸载插件非常繁琐的问题。但使用vundle之后，你只要在文件中添加一行你的插件名再安装就OK了.这里简单说一下Vundle的使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vundle Github 地址:https://github.com/gmarik/vundle&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Vundle安装&lt;/h2&gt;

&lt;h3&gt;创建~/.vim和文件.vimrc&lt;/h3&gt;

&lt;p&gt;进入你的home目录创建.vim文件夹和.vimrc文件&lt;/p&gt;

&lt;h3&gt;获取vundle&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    $ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;编辑如下内容到.vimrc文件&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    &amp;quot; &amp;quot;开头的为注释,仅为说明
    set nocompatible               &amp;quot; be iMproved
    filetype off                   &amp;quot; required!

    set rtp+=~/.vim/bundle/vundle/
    call vundle#rc()

    &amp;quot; let Vundle manage Vundle
    &amp;quot; required! 
    Bundle &amp;#39;gmarik/vundle&amp;#39;

    &amp;quot; My Bundles here:
    &amp;quot; 需要安装的插件都写在这下面

    &amp;quot; original repos on github
    &amp;quot; 插件来自github,写在下方，只要作者名/项目名就可以了
    &amp;quot; Bundle &amp;#39;tpope/vim-fugitive&amp;#39;
    &amp;quot; Bundle &amp;#39;Lokaltog/vim-easymotion&amp;#39;
    &amp;quot; Bundle &amp;#39;rstacruz/sparkup&amp;#39;, {&amp;#39;rtp&amp;#39;: &amp;#39;vim/&amp;#39;}
    &amp;quot; Bundle &amp;#39;tpope/vim-rails.git&amp;#39;

    &amp;quot; vim-scripts repos
    &amp;quot; 插件来自vim-scripts，直接写插件名就可以了
    &amp;quot; Bundle &amp;#39;L9&amp;#39;
    &amp;quot; Bundle &amp;#39;FuzzyFinder&amp;#39;

    &amp;quot; non github repos
    &amp;quot; 非github上的插件。如下：
    &amp;quot; Bundle &amp;#39;git://git.wincent.com/command-t.git&amp;#39;

    &amp;quot; git repos on your local machine (ie. when working on your own plugin)
    &amp;quot; Bundle &amp;#39;file:///Users/gmarik/path/to/plugin&amp;#39;

    filetype plugin indent on     &amp;quot; required!

    &amp;quot; Brief help
    &amp;quot; Vundle的一些指令说明   
    &amp;quot; :BundleList          - list configured bundles
    &amp;quot; :BundleInstall(!)    - install(update) bundles
    &amp;quot; :BundleSearch(!) foo - search(or refresh cache first) for foo
    &amp;quot; :BundleClean(!)      - confirm(or auto-approve) removal of unused bundles
    &amp;quot;
    &amp;quot; see :h vundle for more details or wiki for FAQ
    &amp;quot; NOTE: comments after Bundle command are not allowed..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;安装你的插件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将要安装的插件加入.vimrc文件&lt;/li&gt;
&lt;li&gt;保存.vimrc文件退出当前的vim&lt;/li&gt;
&lt;li&gt;重新打开Vim,输入命令&lt;code&gt;:BundleInstall&lt;/code&gt;,然后vim就会自动安装你的插件了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;如何删除插件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;编辑.vimrc文件删除你要移除的插件行（注释或删除）&lt;/li&gt;
&lt;li&gt;保存.vimrc文件并退出Vim&lt;/li&gt;
&lt;li&gt;重新打开Vim,输入命令&lt;code&gt;:BundleClean&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;插件及插件配置说明：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;插件配置中，许多都设置了按键映射，不喜欢的可以不用配置按键映射&lt;/li&gt;
&lt;li&gt;本文推荐的部分脚本仅适用于C/C++开发，如用其他编程语言开发的，可再找其他合适的脚本&lt;/li&gt;
&lt;li&gt;有些脚本需要先安装ctags才能支持，ctags和cscope的安装配置网上一大堆，这里就不说了，推荐一个个人认为比较好的吧！&lt;a href=&quot;http://blog.csdn.net/wooin/article/details/1858917&quot;&gt;手把手教你把Vim改装成一个IDE变成环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;没有操作说明的即为安装好插件即可以使用,没有配置说明的表示不需要配置也可以使用&lt;/li&gt;
&lt;li&gt;由于整理的匆忙，所列插件并没有按序排列&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;a.vim&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：快速切换.cpp(.c)文件和.h文件&lt;/li&gt;
&lt;li&gt;操作：输入命令:A或:AV切换.c与同名.h文件&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;a.vim&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Mark&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：高亮多个关键字&lt;/li&gt;
&lt;li&gt;操作：mm高亮/取消高亮当前光标下的关键字，ma取消所有高亮关键字&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;Mark&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Tagbar&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能: 标签导航&lt;/li&gt;
&lt;li&gt;操作：一般模式下输入tg打开或关闭Tagbar&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;Tagbar&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;The-NERD-tree&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：开启目录树导航&lt;/li&gt;
&lt;li&gt;操作：一般模式下输入tr打开或关闭The-NERD-Tree&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;The-NERD-tree&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;The-NERD-Commenter&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：块注释&lt;/li&gt;
&lt;li&gt;操作：一般模式下输入cc注释或取消注释当前行，或输入9cc注释当前行开始接下来的9行&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;The-NERD-Commenter&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;YouCompleteMe&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：自动补全&lt;/li&gt;
&lt;li&gt;操作：自动补全时按向下方向键或CTRL+N键选择要补全的内容&lt;/li&gt;
&lt;li&gt;说明：最后一条映射key&lt;em&gt;list&lt;/em&gt;select是为了解决与UltiSnip插件的Tab键冲突问题，默认list_select键为Tab，如果不需要安装UltiSnip插件，可注释该条配置，使用默认Tab键进行list选择&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;Valloric/YouCompleteMe&amp;#39;，下载号插件以后，还需要进行编译，操作比较复杂，具体查看&lt;a href=&quot;http://junewater.github.io/vim/2013/12/11/youcompleteme.html&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;c.vim&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：高亮C/C++类与函数名&lt;/li&gt;
&lt;li&gt;说明：这个是我从网上找的高亮脚本，稍微修改了下，使高亮颜色与desert配色方案搭配，不需要的可以无视哈，或下载插件后自己修改颜色&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;JuneWater/c.vim&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;lua.vim&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：提供lua脚本编辑增强功能&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;lua.vim&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Tabular&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：对齐文本&lt;/li&gt;
&lt;li&gt;操作：在vim命令行模式下输入 :Tab /要根据其对齐的字符，如:Tab /&amp;quot;&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;Tabular&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;mru.vim&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：列出最近打开文件列表&lt;/li&gt;
&lt;li&gt;操作：在vim命令行模式下输入:MRU&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;vim-scripts/mru.vim&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;UltiSnips&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：快速插入自定义号的代码片段(强烈推荐)&lt;/li&gt;
&lt;li&gt;操作：详细操作安装过程请看&lt;a href=&quot;https://github.com/SirVer/ultisnips&quot;&gt;官方文档以及视频&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;说明：如果安装YouCompleteMe而没有将YCM默认Tab键配置过，可能会导致Ultisnips的Tab键冲突，无法使用&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;UltiSnips&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;xml&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：书写xml文件时自动补全标签&lt;/li&gt;
&lt;li&gt;说明：这里我没有安装，因为默认只会对.xml,html等xml文件自动补全，而对.c或.cpp文件等不支持，而我需要在.c和.cpp中书写xml消息，这个插件对我来说没什么用。如果有人知道怎么使得这个插件支持其他类型的文件的，麻烦留言告知下，感激不尽!&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;xml.vim&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;taglist&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;列出源文件中的tag并跳转&lt;/li&gt;
&lt;li&gt;操作：一般模式下输入tl打开或关闭taglist窗口&lt;/li&gt;
&lt;li&gt;说明：taglist依赖于ctags，所以要先安装ctags，否则taglist装了也没法用&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;taglist.vim&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;syntastic&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：静态语法以及风格检查&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;scrooloose/syntastic&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;vim-misc&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：lua.vim需要&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;xolox/vim-misc&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;delemitMate&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：输入引号，括号时，自动补全&lt;/li&gt;
&lt;li&gt;操作：输入(时，自动补全为()并且光标停在括号中，其他类似&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;Raimondi/delimitMate&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;vim-markdown&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：提供markdown文件语法支持&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;plasticboy/vim-markdown&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;ctrlp.vim&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：文件搜索&lt;/li&gt;
&lt;li&gt;操作：普通模式下按CTRL+P搜索文件，命令行模式下:CTRL+P搜索之前的命令&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;kien/ctrlp.vim&amp;#39;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;ack.vim&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;功能：搜索当前文件夹下文件中的关键字，自动忽略.svn和.git中的内容&lt;/li&gt;
&lt;li&gt;操作：一般模式下按F2自动搜索当前光标下关键字，命令行模式下输入:Ack 关键字，当然有多种模式可以选择，具体查看help&lt;/li&gt;
&lt;li&gt;安装：Bundle &amp;#39;ack.vim&amp;#39;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Ubuntu12.04下自动补齐插件YouCompleteMe安装</title>
   <link href="Localhost/2013/12/11/youcompleteme.html"/>
   <updated>2013-12-11T00:00:00+08:00</updated>
   <id>Localhost/2013/12/11/youcompleteme</id>
   <content type="html">&lt;h2&gt;说明&lt;/h2&gt;

&lt;p&gt;转载：从哪里转来的忘记了-_-，对不起原作者了Orz，知道的麻烦留言回复下：&lt;/p&gt;

&lt;p&gt;本文主要是Ubuntu12.04上配置YouCompleteMe(以后简称YCM)的总结，主要是参考的&lt;a href=&quot;https://github.com/Valloric/YouCompleteMe&quot;&gt;这里&lt;/a&gt;,
其他的通过安装Vundle和备份vimrc就很好搞定，不多说了。vimrc和其他一些软件可以&lt;a href=&quot;https://github.com/wklken/k-vim&quot;&gt;参考这里&lt;/a&gt;,我主要是借鉴这里的。目前主要是拷贝有用的过来，以后能用上的在自己修改吧。&lt;/p&gt;

&lt;h2&gt;安装vim&lt;/h2&gt;

&lt;p&gt;首先，这个东西对Vim的版本有要求( Vim 7.3.584及以上)，在apt-get下的vim版本太低，所以需要重新编译vim安装，
关于这个可以&lt;a href=&quot;https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source&quot;&gt;参考这里&lt;/a&gt;，基本照做就行。&lt;/p&gt;

&lt;h2&gt;安装Vundle&lt;/h2&gt;

&lt;p&gt;这个东西是管理vim插件的一个插件。具体办法不用多说，直接上官方&lt;a href=&quot;https://github.com/gmarik/vundle#about&quot;&gt;地址&lt;/a&gt;，注意下vimrc的配置就好，
用起来非常好使，直接在vimrc添加所需的插件的地方就好，比如我要安装YouCompleteMe那么在vimrc中首先添加:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Bundle &amp;quot;Valloric/YouCompleteMe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后进入vim，运行&lt;code&gt;:BundleInstall&lt;/code&gt;,然后就行了(当然YouCompleteMe也是需要这个的，但是折腾的地方主要不在这)&lt;/p&gt;

&lt;h2&gt;安装ack.vim&lt;/h2&gt;

&lt;p&gt;在ubuntu中得首先安装&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;sudo apt-get install ack-grep
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后用vimrc就行&lt;/p&gt;

&lt;h2&gt;安装YCM&lt;/h2&gt;

&lt;p&gt;一般vim插件的安装基本上到上面就基本结束了，但这个要麻烦点，我们得继续安装YCM，主要是编译下ycm_core.
准备工作:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;sudo apt-get install build-essential cmake
sudo apt-get install python-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要带上是C/C++的话:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cd ~/.vim/bundle/YouCompleteMe
./install.sh --clang-completer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有C/C++的话就比较简单:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cd ~/.vim/bundle/YouCompleteMe
./install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;理论上这样应该就可以的，但是我这边不行，主要是没有libclang.so这个东西，这个libclang.so貌似系统
没有，我locate libclang.so 是不行的，apt-cache search llvm的最高版本貌似没有3.3，所以我手动装了.
Ubuntu上详细的安装可以见这里,&lt;a href=&quot;http://solarianprogrammer.com/2013/01/17/building-clang-libcpp-ubuntu-linux/&quot;&gt;这个&lt;/a&gt;还有libc++的配置，不过因为要翻墙，所以在这里把我用到的备份下.
准备工作:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;sudo apt-get install g++ subversion
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着下载llvm的源码安装即可，我把源码放在~下了,当然可以是随意的地方:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cd ~
mkdir Clang &amp;amp;&amp;amp; cd Clang
svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
cd llvm/tools
svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后编译就好了，注意下路径就好:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cd ..
cd ..
mkdir build &amp;amp;&amp;amp; cd build
../llvm/configure --prefix=/usr/clang_3_3 --enable-optimized --enable-targets=host
make -j 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后安装Clang:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置下环境变量在~/.bashrc下加这么一句就好:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;export PATH=/usr/clang_3_3/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的工作比较简单:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cd ~
mkdir ycm_build
cd ycm_build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成Makefile:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cmake -G &amp;quot;Unix Makefiles&amp;quot; . ~/.vim/bundle/YouCompleteMe/cpp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这不要C/C++其实就好了，不过折腾了那么久就是为了C/C++，所以还得继续。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt; cmake -G &amp;quot;Unix Makefiles&amp;quot; -DEXTERNAL_LIBCLANG_PATH=/usr/clang_3_3/lib/libclang.so .
 ~/.vim/bundle/YouCompleteMe/cpp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个我是指定的动态库的地址，这样configure就不会说缺少这个库了。最后:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;make ycm_core
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，注意下配置那个vimrc的配置就好了，全文收工。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Lua脚本语言学习笔记</title>
   <link href="Localhost/2013/12/09/lua.html"/>
   <updated>2013-12-09T00:00:00+08:00</updated>
   <id>Localhost/2013/12/09/lua</id>
   <content type="html">&lt;h2&gt;开始&lt;/h2&gt;

&lt;p&gt;Lua脚本是一个很轻量级的脚本，也是号称性能最高的脚本，用在很多需要性能的地方，比如：游戏脚本，nginx，wireshark的脚本。&lt;/p&gt;

&lt;h3&gt;语法规范&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    #注视代码块
    --[[
        print(10)
    --]]
    #取消注释
    ---[[
        print(10)
    --]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;解释器程序&lt;/h3&gt;

&lt;p&gt;lua [选项参数] [脚本[参数]]
* -e 可以直接在命令喊中输入代码，例如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    $ lua -e &amp;quot;print(math.sin(12))&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;-l 用于加载库文件&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-i 在运行完其他命令行参数后进去交互模式。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ lua -i -l a -e &amp;quot;x=10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以定义一个名为&amp;quot;_PROMPT&amp;quot;的全局变量，解释器就会用它的值作为交互模式的命令提示符。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    $ lua -i -e &amp;quot;_PROMPT=&amp;#39;June\&amp;#39;s lua&amp;gt;&amp;#39;&amp;quot;
    ---&amp;gt;June&amp;#39;s lua&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在交互模式中，需要打印任何表达式的值，可以用=开头，并跟随一个表达式，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    June&amp;#39;s lua&amp;gt;=math.sin(3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、类型与值&lt;/h2&gt;

&lt;p&gt;Lua中有8中基础类型，函数type可根据一个值返回其类型名称&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    print(type(print))      ---&amp;gt;function
    print(type(type(X)))    ---&amp;gt;string
    #永远返回&amp;quot;string&amp;quot; 因为type函数返回一个字符串
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;nil(空):全局变量第一次赋值前的默认值是nil,将nil赋予一个全局变量等于删除它&lt;/li&gt;
&lt;li&gt;boolean(布尔)：true和false，Lua将值false和nil视为&amp;quot;假&amp;quot;，其他均为&amp;quot;真&amp;quot;&lt;/li&gt;
&lt;li&gt;number(数字)：表示实数，双精度浮点数&lt;/li&gt;
&lt;li&gt;&lt;p&gt;string(字符串)：字符串是不可变的值，不能像C语言中那样直接修改字符串的某个字符，而是应该根据修改要求来创建一个新的字符串&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;\a:响铃
\b:退格
\f：提供表格
\n:换行
\r：回车
\t：水平tab
\v：垂直tab
\\反斜杠
\&amp;quot;双引号
\&amp;#39;单引号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lua在运行时提供了数字与字符串的自动转换，如果需要显式地将一个字符串转换成数字，可以使用函数tonumber。若要将一个数字转换成字符串，可以调用函数tostring,或者将该数字与一个空字符串相连接，在Lua5.1中，可以在字符串前放置操作符&amp;quot;#&amp;quot;来获得该字符串的长度。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;uerdata(自定义类型)：用于表示一种由应用程序或C语言库所创建的新类型&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;function(函数)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;thread(线程)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;table(表)：table.maxn函数，返回一个table的最大正索引数，当对索引的实际类型不是很确定时，可以明确地使用一个显式转换&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;3、表示式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;关系操作符：对于table、userdata和函数，Lua是作引用比较的，也就是说，只有当它们引用同一个对象时，才认为它们相等。&lt;/li&gt;
&lt;li&gt;逻辑操作符：对于操作符and来说，如果它的第一个操作数为假，就返回第一个操作数;不然返回第二个操作数。对于操作符or来说，如果第一个操作数为真，就返回第一个操作数；不然返回第二个操作数。and的优先级高于or&lt;/li&gt;
&lt;li&gt;字符串连接：&amp;quot;..&amp;quot;如果任意一个操作数是数字的话，Lua会将这个数字转换成一个字符串。连接操作符智慧创建一个新的字符串，不会对原操作数进行任何修改。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优先级&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;^&amp;gt;not # -(一元)&amp;gt;* / %&amp;gt;+ -&amp;gt;..&amp;gt;&amp;lt; &amp;gt; &amp;lt;= &amp;gt;= ~= ==&amp;gt;and&amp;gt;or
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;4、语句&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多重赋值并不会比相等价的多条单一变量赋值语句更快，但有时的确会需要多重赋值，例如交换两个变量，收集函数的多个返回值。&lt;/li&gt;
&lt;li&gt;局部变量和块：局部变量的作用于仅限于申明它们的那个块。一个块是一个控制结构的执行体、或者是一个函数的执行体或者是一个程序块。在交互模式中，每行输入内容自身就形成了一个程序块，可以用do-end显式地界定一个块。&amp;quot;尽可能的使用局部变量！&amp;quot;，访问局部变量比访问全局变量更快。&amp;#39;local foo = foo&amp;#39;创建一个局部变量，并将用全局变量foo的值初始化它。&lt;/li&gt;
&lt;li&gt;一个申明在循环体中的局部变量的作用于包括了条件测试(5.1新功能)&lt;/li&gt;
&lt;li&gt;数字型for循环中，3个表达式是在循环开始前一次性求值的，不设置循环上限:（math.huge）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;泛型for循环通过一个迭代器(iterator)函数来遍历所有值，标准库提供了几种迭代器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;io.lines:迭代文件中的每行
pairs:迭代table元素
ipairs:迭代数组元素
string.gmatch:迭代字符串中单词
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数字型和泛型for循环：控制变量会被自动申明为for语句的局部变量，并且仅在循环体内可见。不要在循环过程中修改控制变量的值，否则会导致不可预知的效果。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;5、函数&lt;/h2&gt;

&lt;h3&gt;多重返回值&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;函数调用作为一条单独语句时，Lua会丢弃函数的所有返回值&lt;/li&gt;
&lt;li&gt;函数作为表达式的一部分来调用时，Lua只保留函数的第一个返回值&lt;/li&gt;
&lt;li&gt;只有当一个函数调用是一系列（多重赋值，函数调用时传入的实参列表，table的构造式和return语句）表达式中的最后一个元素时，才能获得它的所有返回值&lt;/li&gt;
&lt;li&gt;可以将一个函数调用放入一对圆括号中，从而迫使它只有一个返回结果&lt;/li&gt;
&lt;li&gt;unpack:接受一个数组作为参数，并从下标1开始返回该数组的所有元素，unpack的一项重要用途体现在&amp;quot;泛型调用(generic call)&amp;quot;机制中。泛型调用机制可以动态地以任何实参来调用任何参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;变长参数(variable number of arguments)&lt;/h3&gt;

&lt;p&gt;参数列表中的3个点表示该函数可接受不同数量的实参。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;string.format:格式化文本函数&lt;/li&gt;
&lt;li&gt;io.write:输出文本函数&lt;/li&gt;
&lt;li&gt;select：必须传入一个固定实参selector（选择开关）和一系列变长参数，如果selector为数字n，那么select返回它的第n个可变实参，否则，selector只能为字符串&amp;quot;#&amp;quot;,这样select会返回变长参数的总数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;具名实参&lt;/h3&gt;

&lt;p&gt;将所有实参组织到一个table中，并将这个table作为唯一的实参传给函数&lt;/p&gt;

&lt;h2&gt;6、深入函数&lt;/h2&gt;

&lt;p&gt;函数和所有其他值一样都是匿名的，即它们都没有名称。一个函数定义实际就是一条赋值语句，这条语句创建了一种类型为”函数“的值，并将这个值赋予一个变量。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;table.sort:接受两个元素，并返回在有序情况下第一个元素是否应排在第二个元素前&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;closure（闭合函数）&lt;/h3&gt;

&lt;p&gt;若将一个函数写在另一个函数之内，那么这个位于内部的函数便可以访问外部函数中的局部变量，这个特征称之为&amp;quot;词法域&amp;quot;。&lt;/p&gt;

&lt;p&gt;closure是指一个函数及一些列这个函数会访问到&amp;quot;非局部的变量（或upvalue)&amp;quot;，因此若一个closure没有那些会访问的&amp;quot;非局部变量&amp;quot;，那它就是一个传统概念中的&amp;quot;函数&amp;quot;&lt;/p&gt;

&lt;h3&gt;尾调用&lt;/h3&gt;

&lt;p&gt;在Lua中，只有&amp;quot;return&lt;func&gt;(&lt;args&gt;)&amp;quot;这样的调用形式才算是一条&amp;quot;尾调用&amp;quot;，Lua会在调用前对&lt;func&gt;及其参数求值，所以它们可以是任意复杂的表达式。&lt;/p&gt;

&lt;h2&gt;7、迭代器与泛型for&lt;/h2&gt;

&lt;h3&gt;泛型for的语义&lt;/h3&gt;

&lt;p&gt;泛型for在循环过程内部保存了迭代器函数。实际上它保存着3个值：一个迭代器函数、一个很恒定状态（invariant state）和一个控制变量（control variable）&lt;/p&gt;

&lt;p&gt;泛型for的语法如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    for&amp;lt;var-list&amp;gt;in&amp;lt;exp-list&amp;gt;do
        &amp;lt;body&amp;gt;
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;&amp;lt;var-list&amp;gt;&lt;/code&gt;是一个或多个变量的列表，以逗号分隔;&lt;code&gt;&amp;lt;exp-list&amp;gt;&lt;/code&gt;是一个或多个表达式的列表，同样以逗号分隔。通常表达式列表只有一个元素，即一句对迭代器工厂的调用。&lt;/p&gt;

&lt;p&gt;for做的第一件事情是对in后面的表达式求值。这些表达式一个返回3个值供for保存：迭代器函数、恒定状态和控制变量的初值。初始化之后，for会以恒定状态和控制变量来调用迭代器函数。然后for将迭代器函数的返回值赋予变量列表中的变量。如果第一个返回值为nil，那么循环终止&lt;/p&gt;

&lt;h3&gt;无状态的迭代器&lt;/h3&gt;

&lt;p&gt;一种自身不保存任何状态的迭代器，因此，我们可以在多个循环中使用同一个无状态的迭代器，比便创建新的closure开销。&lt;/p&gt;

&lt;h3&gt;具有复杂状态的迭代器&lt;/h3&gt;

&lt;p&gt;通常一个基于closure实现的迭代器会比一个使用table的迭代器更高效，这是因为，首先创建一个closure就比创建一个table更廉价，其次范文&amp;quot;非局部变量&amp;quot;比访问table字段更快。&lt;/p&gt;

&lt;h2&gt;8、编译、执行与错误&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;loadstring总是在全局环境中编译它的字符串&lt;/li&gt;
&lt;li&gt;Lua将所有独立的程序块视为一个匿名函数的函数体，并且该匿名函数还具有可变长实参。&lt;/li&gt;
&lt;li&gt;assert函数检查其第一个参数是否为true，若为true，则简单返回该参数false就引发一个错误，它的第二个参数是一个可选的信息字符串。&lt;/li&gt;
&lt;li&gt;pcall函数会以一种&amp;quot;保护模式(protected mode)&amp;quot;来调用它的第一个参数，因此pcall可以捕获函数执行中的任何错误。当pcall返回其错误信息时，它已经销毁了调用栈的部分内容，也就是从pcall到错误发生点的这部分调用。&lt;/li&gt;
&lt;li&gt;xpcall：该函数除了接受一个需要被调用的函数之外，还接受第二个参数----一个错误处理函数。当发生错误时，Lua会在调用栈展开前调用错误处理函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;9、协同程序（coroutine）&lt;/h2&gt;

&lt;h3&gt;协同程序基础&lt;/h3&gt;

&lt;p&gt;一个具有多个协同程序的程序在任意时刻只能运行一个协同程序，并且正在运行的协同程序只会在其显式地要求挂起（suspend)时，它的执行才会停止。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在第一次调用resume时，并没有对应的yield在等待她，因此所有传递给resume的额外参数都将视为协同程序主函数的参数。在resume调用返回的内容中，第一个值为true则表示没有错误，而后面所有的值都是对应yield传入的参数。当一个协同程序结束时，它的主函数所返回的值都将作为对应resume的返回值&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>正则表达式(regular expression)笔记</title>
   <link href="Localhost/2013/12/02/regex.html"/>
   <updated>2013-12-02T00:00:00+08:00</updated>
   <id>Localhost/2013/12/02/regex</id>
   <content type="html">&lt;h2&gt;一、正则表达式入门&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;代表一行的开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt;代表一行的结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;匹配任意字符的字符组的简便写法，在字符组中，&lt;code&gt;.&lt;/code&gt;不是元字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;字符组&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sep[ea]r[ea]te&lt;/code&gt;匹配seperate separate separete seperete等 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt;在字符组内部代表范围，H[1-6]与H[123456]一致，如果出现在字符组开头，它代表的就是一个普通字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt;和&lt;code&gt;!&lt;/code&gt;通常被当做元字符，挡在字符组中就不是如此&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;排除性字符组&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[^1-6]&lt;/code&gt;匹配除了1到6以外的任何字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;多选结构&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt;它的意思是&amp;quot;或&amp;quot;，&lt;code&gt;Bor|Robert&lt;/code&gt;就是能够同时匹配其中任意一个的正则表达式，在字符组中，它只是一个普通字符.&lt;/li&gt;
&lt;li&gt;注意:&lt;code&gt;^From|Subject|Date:*&lt;/code&gt;和&lt;code&gt;^（From|Subject|Date）:*&lt;/code&gt;匹配结果是不一样的.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;忽略大小写&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;egrep的命令行参数&amp;quot;-i&amp;quot;表示进行忽略大小写的匹配，写在正则表达式之前.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;单词分界符&lt;/h3&gt;

&lt;p&gt;前提:egrep支持”元字符序列“&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;&lt;/code&gt;和&lt;code&gt;\&amp;gt;&lt;/code&gt;用来匹配单词分界的位置。&lt;code&gt;\&amp;lt;cat\&amp;gt;&lt;/code&gt;匹配cat这个单词.&lt;code&gt;\&amp;lt;cat&lt;/code&gt;&lt;code&gt;cat\&amp;gt;&lt;/code&gt;用来匹配以cat开头和结束的单词.&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;本身不是元字符，只有当它们和斜线结合起来的时候。整个序列才具有特殊意义，所以称之为元字符序列.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;可选项元素&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 代表可选项.把它加在一个字符的后面，就表示此处容许出现这个字符，不过它的出现并非匹配成功的必要条件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;其他量词：重复出现&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;表示之前紧邻的元素出现一次或多次，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;表示之前紧邻的元素出现任意多次，或者不出现.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;规定重现次数的范围：区间&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;某些本版本的egrep能够使用元字符序列来自定义出现次数的区间：&lt;code&gt;[a-zA-z]{1,5}&lt;/code&gt;来匹配1到5个字母&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;括号及反向引用&lt;/h3&gt;

&lt;p&gt;括号的两种用途：限制多选项的范围;将若干字符组合为一个单元，受问号或星号之类量词的作用。
反向引用例子：&lt;code&gt;\&amp;lt;([a-z]+)+\1\&amp;gt;&lt;/code&gt;用来查找连续的重复单词，但egrep吧每行文字都当做一个独立部分来看待，所以如果两个单词在不同行，这个表达式就无法找到.&lt;/p&gt;

&lt;h3&gt;神奇的转义&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt; 作用的元字符会失去特殊意义，成了普通字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Note:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;egrep会在检查正则表达式之前把每一行的换行符去掉&lt;/li&gt;
&lt;li&gt;在字符组内部，元字符的定义规则以及它们的意义是不一样的&lt;/li&gt;
&lt;li&gt;无论列出的字符有多少，字符组只能匹配一个字符。相反，多选项可以匹配任意长度的文本，每个多选项可能匹配的文本都是独立的，多选项没有像字符数组那样的排除功能&lt;/li&gt;
&lt;li&gt;排除性子附注是表示所有未列出的字符组的简便方法,因此，&lt;code&gt;[^x]&lt;/code&gt;的意思不是”只有当这个位置不是x时才能匹配“，而是说”匹配一个不等于x的字符&amp;quot;&lt;/li&gt;
&lt;li&gt;大多数程序设计语言和工具都支持字符数组内部的转义，但是大多数版本的egrep不支持，它们会把反斜线当做字符组内部列出的普通字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;更多的列子&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;匹配时间：&lt;code&gt;(1[012]|[1-9]):[0-5][0-9](am|pm)&lt;/code&gt;或&lt;code&gt;[01]?[0-9]|2[0-3]:[0-5][0-9]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;二、入门示例扩展&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在尝试匹配时，正则表达式中的元字符&lt;code&gt;\1&lt;/code&gt;指向之前匹配的某些文本，匹配成功之后，在接下来的程序中用&lt;code&gt;$1&lt;/code&gt;来引用同样的文本&lt;/li&gt;
&lt;li&gt;非捕获型括号&lt;code&gt;(?:...)&lt;/code&gt;表示只分组，不捕获&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;许多流派的正则表达式提供的简记法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\b&lt;/code&gt; 在perl中，匹配一个单词的分界符，但是在字符组中，它匹配一个退格符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\t&lt;/code&gt; 制表符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt; 换行符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\r&lt;/code&gt; 回车符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\s&lt;/code&gt; 任何“空白”的字符(例如空格符、制表符等)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\S&lt;/code&gt; 除&lt;code&gt;\s&lt;/code&gt;以外的任何字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\w&lt;/code&gt; &lt;code&gt;[a-z0-9A-Z]&lt;/code&gt;(在&lt;code&gt;\w+&lt;/code&gt;中很有用，可以用来匹配一个单词)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\W&lt;/code&gt; 除&lt;code&gt;\w&lt;/code&gt;之外的任何字符，也就是&lt;code&gt;[^a-zA-Z0-9]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\d&lt;/code&gt; &lt;code&gt;[0-9]&lt;/code&gt;，即数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\D&lt;/code&gt; 除&lt;code&gt;\d&lt;/code&gt;外的任何字符，即&lt;code&gt;[^0-9]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;使用正则表达式修改文本&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s/.../.../*&lt;/code&gt;将前面的字符串内容替换为后面的字符串内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s/.../.../g&lt;/code&gt; &lt;code&gt;/g&lt;/code&gt;表示全局替换，它告诉&lt;code&gt;s/.../.../&lt;/code&gt;在第一次替换完成之后继续搜索更多的匹配文本，进行更多的替换.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s/\bJeff\b/Jeff/i&lt;/code&gt;搜索&amp;quot;Jeff&amp;quot;这个词是不区分大小写的。而所有匹配的字符串都会被替换为&amp;quot;Jeff&amp;quot;，第一个字母是大写，其他为小写.&lt;code&gt;/i&lt;/code&gt;对replacement的文本没有影响&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s/(\.\d\d[1-9]?)\d*/$1/&lt;/code&gt;保留小数点后梁如数字，如果第三位不为0,也需要保留&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/^\s*$/&lt;/code&gt;检测空格行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/^Subject:(.*)/i&lt;/code&gt;不区分大小写匹配Subject，将之后的内容捕获&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\S+&lt;/code&gt;匹配第一个空白之前的文本（或者目标文本末尾之前的所有字符）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s/^/|&amp;gt;/&lt;/code&gt;在开头加入&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;用环视功能为数值添加逗号&lt;/h3&gt;

&lt;p&gt;环视结构不匹配任何字符，只匹配文本中的特定位置，环视不会占用字符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;顺序环视：顺序环视顺序（从左到右）查看文本，尝试匹配子表达式，如果能够匹配，就返回匹配成功信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(?=...)&lt;/code&gt;:肯定顺序环视&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(?!...)&lt;/code&gt;:否定顺序环视&lt;/li&gt;
&lt;li&gt;逆序环视：它逆序（从右到左）查看文本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(?&amp;lt;=...)&lt;/code&gt;:肯定逆序环视&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(?&amp;lt;!...)&lt;/code&gt;:否定逆序环视&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;顺序环视示例&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(?=Jeffey)Jeff&lt;/code&gt;它只能匹配&amp;quot;Jerrfrey&amp;quot;这个单词中的&amp;quot;Jeff&amp;quot;，它与&lt;code&gt;Jeff(?=rey)&lt;/code&gt;等价&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s/\bJeff(?=s\b)/Jeff&amp;#39;/g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s/(?&amp;lt;=\bJeff)(?=s\b)/&amp;#39;/g&lt;/code&gt;匹配了我们希望插入撇号的位置。在这种情况下，我们并没有“替换”任何字符，而只是插入了一个撇号。且与&lt;code&gt;s/(?=s\b)(?&amp;lt;=\bJeff)/&amp;#39;/g&lt;/code&gt;等价。无论是先检查左边，再检查右边，还是相反，关键是，在同一位置两边的检测必须都能成功，整个匹配才算成功。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s/(?&amp;lt;=\d)(?=(\d\d\d)+$&lt;/code&gt;/,/g 在2238748274数字中每隔3个数字加入&amp;quot;,&amp;quot;即2,238,748,274，PS:若不捕获，可以用&lt;code&gt;(?:\d\d\d)&lt;/code&gt;
*&lt;code&gt;(?&amp;lt;!\w)(?=\w)&lt;/code&gt; 表示单词起始分界符
*&lt;code&gt;(?&amp;lt;=\w)(?!\w)&lt;/code&gt; 表示单词结束分界符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s/(\d)(?=(\d\d\d)+(?!\d)/$1,/g&lt;/code&gt;不通过你逆序环视添加逗号&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Note&lt;/h4&gt;

&lt;p&gt;一次迭代完成时，下一次的迭代会从上一次匹配的终点开始尝试。使用环视的意义在于，检查某个位置，但检查时匹配的字符并不算在（最终）“匹配的字符串”内。&lt;/p&gt;

&lt;h2&gt;三、正则表达式的特性和流派概览&lt;/h2&gt;

&lt;p&gt;在某种特定的宿主语言或工具软件中使用正则表达式时，主要有三个问题值得注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持的元字符，以及这些元字符的意义。这通常成为正则表达式的“流派(flavor)”&lt;/li&gt;
&lt;li&gt;正则表达式与语言或工具的“交互”(interface)方式。譬如如何进行正则表达式操作，容许进行哪些操作，以及这些操作的目标文本类型。&lt;/li&gt;
&lt;li&gt;正则表达式引擎如何将表达式应用到文本。语言或工具的设计者实现正则表达式的方法，对正则表达式能够取得的结果有重要的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，程序设计语言有3中处理正则表达式的方式：级城市(integrated)、程序是(procedural)和面向对象式(object-oriented)。在第一种方式中，正则表达式是直接内建在语言中的，Perl就是如此。但是在其他两种方式中，正则表达式不属于语言的低级语法。相反，普通的函数接受普通的字符串，把它们作为正则表达式进行处理。由不太能够的函数进行不通的、关系到一个或多个正则表达式的操作。大多数语言（不包括perl)采用的都是这两种方式之一，包括Java、.NET、Tcl、Python、PHP、Emacs、lisp和Ruby。&lt;/p&gt;

&lt;h3&gt;正则模式和匹配模式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不区分大小写的匹配模式 i&lt;/li&gt;
&lt;li&gt;宽松排列和注释模式：忽略字符组外部的所有空白字符 x&lt;/li&gt;
&lt;li&gt;点号通配模式(dot-match-all match mode，也叫&amp;quot;单行模式&amp;quot;) s&lt;/li&gt;
&lt;li&gt;增强的行锚点模式(Enhanced line-anchor match mode,也叫&amp;quot;多行文本模式&amp;quot;) m&lt;/li&gt;
&lt;li&gt;文字文本模式：文字文本模式几乎不能识别任何正则表达式元字符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;常见的元字符和特性&lt;/h3&gt;

&lt;h4&gt;字符表示法：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\a&lt;/code&gt; 警报&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\e&lt;/code&gt; Escape字符,通常对应ASCII中的&lt;code&gt;&amp;lt;ESC&amp;gt;&lt;/code&gt;字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\v&lt;/code&gt; 垂直制表符&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;八进制转义\num&lt;/h4&gt;

&lt;p&gt;支持八进制转义方式通常容许以2到3位数字表示该值所代表的字节或字符。八进制转义可以很方便地在正则表达式中插入平时难以输入的字符&lt;/p&gt;

&lt;h4&gt;十六进制及Unicode转义:\xnum、\x{num}、\unum、\Unum&lt;/h4&gt;

&lt;h4&gt;几乎能匹配任何字符的元字符：点号&lt;/h4&gt;

&lt;p&gt;在某些工具软件中，点号用来缩略表示可以匹配任何字符的字符组，而在其他工具中，点号能匹配除了换行符之外的任何字符，关于点号，需要注意的有：
* 匹配模式会改变点号的匹配规则
* POSIX规定，点号不能匹配NULL（值为0的字符），尽管大多数脚本语言容许文本中出现NULL（而且可以用点号来匹配）&lt;/p&gt;

&lt;h4&gt;POSIX&amp;quot;字符组&amp;quot;方括号表示法&lt;/h4&gt;

&lt;p&gt;我们通常所说的字符组，在POSIX标准中成为方括号表达式(bracket expression)。POSIX中的属于“字符组”指的是在方括号表达式内部使用的一种特殊功能。&lt;/p&gt;

&lt;p&gt;POSIX字符组的详细列表根据locale的变化而变化，但是下面这些通常都能支持：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[:alnum:]&lt;/code&gt; 字母字符和数字字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:alpha:]&lt;/code&gt; 字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:blank:]&lt;/code&gt; 空格和制表符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:cntrl:]&lt;/code&gt; 控制字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:digit:]&lt;/code&gt; 数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:graph:]&lt;/code&gt; 非空字符（即空白字符，控制字符之外的字符）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:lower:]&lt;/code&gt; 小写字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:print:]&lt;/code&gt; 类似&lt;code&gt;[:graph:]&lt;/code&gt;,但是包含空白字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:punct:]&lt;/code&gt; 标点符号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:space:]&lt;/code&gt; 所有的空白字符（&lt;code&gt;[:blank:]&lt;/code&gt;、换行符、回车符及其他）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:upper:]&lt;/code&gt; 大写字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[:xdigit:]&lt;/code&gt; 十六进制中容许出现的数字（例如0-9a-fA-F）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;锚点及其他“零长度断言”&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;行/字符串的其实位置&lt;code&gt;^&lt;/code&gt;、&lt;code&gt;\A&lt;/code&gt; 脱字符&lt;code&gt;^&lt;/code&gt;匹配需要搜索的文本的起始位置，如果使用了增强的行锚点匹配模式，它还能匹配每个换行符之后的位置。如果可以使用，则无论在什么匹配模式下，&lt;code&gt;\A&lt;/code&gt;总是能够匹配待搜索文本的起始位置。&lt;/li&gt;
&lt;li&gt;行/字符串的结束位置：&lt;code&gt;$&lt;/code&gt;、&lt;code&gt;\z&lt;/code&gt;和&lt;code&gt;\Z&lt;/code&gt;.&lt;code&gt;$&lt;/code&gt;最常见的意思是匹配目标字符串的末尾，也可以匹配整个字符串末尾的换行符之前的位置。匹配模式可以改变&lt;code&gt;$&lt;/code&gt;的意义，匹配字符串中的任何换行符。如果支持，&lt;code&gt;\Z&lt;/code&gt;通常表示“未指定任何模式下”&lt;code&gt;$&lt;/code&gt;匹配的字符，通常是字符串的末尾位置，或者是在字符串末尾的换行符之前的位置。作为补充，&lt;code&gt;\z&lt;/code&gt;只匹配字符串的末尾，而不考虑任何换行符&lt;/li&gt;
&lt;li&gt;匹配的起始位置（或者是上一次匹配的结束位置）：&lt;code&gt;\G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;环视:环视结构中，大多数实现方式都限制了逆序环视中的表达式的长度（但是顺序环视则没有限制），在Perl和Python中。逆序环视只能匹配固定长度的文本。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;注释和模式修饰符&lt;/h3&gt;

&lt;h4&gt;模式修饰符：（?modifier),例如(?i)和(?-i)&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;(?i)&lt;/code&gt; 启用不区分大小写的匹配，而&lt;code&gt;(?-i)&lt;/code&gt;会停用此功能。例&lt;code&gt;&amp;lt;B&amp;gt;(?i)very(?-i)&amp;lt;/B&amp;gt;&lt;/code&gt;。除Python之外。大多数实现方式中，&lt;code&gt;(?i)&lt;/code&gt;的作用范围都只限于括号内部（也就是说，在闭括号之后就失效），即&lt;code&gt;&amp;lt;B&amp;gt;(?:(?i)very)&amp;lt;/B&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;模式作用范围：(?modifier:...)，例如(?i:...)&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;(?i:...)&lt;/code&gt;表示模式修饰符的作用范围只有在括号内有效。&lt;/p&gt;

&lt;h4&gt;注释：(?#...)和#...&lt;/h4&gt;

&lt;h4&gt;文字文本范围:\Q...\E&lt;/h4&gt;

&lt;p&gt;它会消除其中除了\E之外所有元字符的特殊含义（如果没有\E，就会一直作用到正则表达式末端）。其中的所有字符都会被当成普通文字文本来对待。如果在构建正则表达式时包含变量，次功能就非常有用。&lt;/p&gt;

&lt;h3&gt;分组，捕获，条件判断和控制&lt;/h3&gt;

&lt;h4&gt;捕获/分组括号：(...)和\1，\2，...&lt;/h4&gt;

&lt;p&gt;捕获型括号的编号是按开括号出现的次序，从左到右计算的。如果提供了反向引用，则这些括号内的子表达式匹配的文本可以在表达式的后面部分用&lt;code&gt;\1&lt;/code&gt;、&lt;code&gt;\2&lt;/code&gt;来引用。&lt;/p&gt;

&lt;h4&gt;仅用于分组的括号：&lt;code&gt;(?:...)&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;仅用于分组的括号&lt;code&gt;(?:...)&lt;/code&gt;不能用来提取文本，而只能用来规定多选结构或者两次的作用对象。&lt;/p&gt;

&lt;h4&gt;命名捕获：(?&lt;name&gt;...)&lt;/h4&gt;

&lt;h4&gt;固化分组：(?&amp;gt;...)&lt;/h4&gt;

&lt;p&gt;一旦括号内的子表达式匹配之后，匹配的内容就固定下来（固化(atomic)下来无法改变），在接下来的匹配过程中不会变化，除非整个固化分组的括号都被弃用，在外部回溯中重新应用。&lt;/p&gt;

&lt;h4&gt;多选结构：...|...|...&lt;/h4&gt;

&lt;p&gt;多选结构的优先级很低，所以&lt;code&gt;this and|or that&lt;/code&gt;的匹配等价于&lt;code&gt;(this and)|(or that)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;条件判断：(?if then |else)&lt;/h4&gt;

&lt;h2&gt;四、表达式的匹配原理&lt;/h2&gt;

&lt;p&gt;正则引擎可以粗略地分为3类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DFA(符合或不符合POSIX标准的都属于此类）&lt;/li&gt;
&lt;li&gt;传统型NFA&lt;/li&gt;
&lt;li&gt;POSIX NFA&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;匹配的基础&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;优先选择最左端的匹配结果，如用&lt;code&gt;fat|cat|belly|your&lt;/code&gt;来匹配字符串&lt;code&gt;The dragging belly indicates that your cat is too fat&lt;/code&gt;的结果是&lt;code&gt;beely&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准的匹配量词(&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;)和&lt;code&gt;{m,n}&lt;/code&gt;是匹配优先的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;引擎构造&lt;/h3&gt;

&lt;p&gt;正则引擎中的零件分为几类————文字字符(literal characters)、量词（qualifiers）、字符组（character classes）、括号，等等。&lt;/p&gt;

&lt;p&gt;锚点可以分为两类：简单锚点（^、$、\G、\b、）和复杂锚点(例如顺序环视和逆序环视）。简单锚点之所以得名，就在于它们只是检查目标字符串中的特定位置的情况，或者是比较两个相邻的字符。相反，复杂锚点能包含任意复杂的子表达式，所以它们也可以任意复杂。&lt;/p&gt;

&lt;h3&gt;表达式主导与文本主导&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;NFA引擎：表达式主导&lt;/li&gt;
&lt;li&gt;DFA引擎：文本主导&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;比较NFA与DFA&lt;/h3&gt;

&lt;p&gt;DFA特性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DFA匹配很迅速&lt;/li&gt;
&lt;li&gt;DFA匹配很一致&lt;/li&gt;
&lt;li&gt;谈论DFA匹配很恼人&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;回溯&lt;/h4&gt;

&lt;p&gt;NFA引擎最重要的性质是，它会依次处理各个子表达式或组成元素，遇到需要在两个可能成功的可能中进行选择的时候，它会选择其一，同时记住另一个，以备稍后可能的需要。&lt;/p&gt;

&lt;p&gt;回溯的两个要点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果需要在“进行尝试”和“跳过尝试”之间选择，对于匹配优先量词，引擎会优先选择“进行尝试”，而对于忽略优先量词，会选择“跳过尝试”。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;距离当前最近存储的选项就是当本地失败强制回溯时返回的。使用的原则是LIFO（last in first out,后进先出）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;匹配优先&lt;/h4&gt;

&lt;p&gt;匹配时只从自身出发，匹配尽可能多的内容，只有在全局匹配需要的情况下才会“被迫”交换一些字符。&lt;/p&gt;

&lt;h4&gt;忽略匹配优先&lt;/h4&gt;

&lt;p&gt;与匹配优先相反&lt;/p&gt;

&lt;h3&gt;占有优先量词和固化分组&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用(?&amp;gt;...)实现固化分组：如果匹配进行到此结构之后（也就是，进行到闭括号之后），那么此结构体中的所有备用状态都会被放弃。也就是说，在固化分组匹配结束时，它已经匹配的文本已经固化为一个单元，只能作为整体而保留或放弃。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Note&lt;/h3&gt;

&lt;p&gt;匹配优先和忽略优先都不会影响需要检测路径的本身，而智慧影响检测的顺序。如果不能匹配，无论是按照匹配优先还是忽略优先的顺序，最终每条路径都会被测试。然而，固化分组与它们截然不同，因为固化分组会放弃某些可能的路径。更具具体情况的不同，放弃备用状态可能会导致不同的结果：
* 毫无影响
* 导致匹配失败
* 改变匹配结果
* 加快报告匹配失败的速度&lt;/p&gt;

&lt;h3&gt;占用优先量词，&lt;code&gt;?+&lt;/code&gt;、&lt;code&gt;*+&lt;/code&gt;、&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;{m,n}+&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;占用优先量词与匹配优先量词很相似，只是它们从来不交还已经匹配的字符。&lt;/p&gt;

&lt;h3&gt;环视中的回溯&lt;/h3&gt;

&lt;p&gt;只要环视结构的匹配尝试结束。它就不会留下任何备用状态。任何备用状态和例子中肯定环视成功时的情况一样，都会被放弃。&lt;/p&gt;

&lt;h3&gt;多选结构&lt;/h3&gt;

&lt;p&gt;传统型NFA引擎，遇到多选结构时，这种引擎会按照从左到右的顺序检查表达式中的多选分支，NFA和POSIX NFA中有匹配优先的多选结构，它们总是匹配所有多选分支中能匹配最多文本的那个。&lt;/p&gt;

&lt;h3&gt;NFA、DFA和POSIX&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;最左最长规则：如果传动装置在文本的某个特定位置启动DFA引擎，而在此位置又有一个或多个可能的匹配，DFA就会选择这些可能中最长的&lt;/li&gt;
&lt;li&gt;POSIX和最左最长规则：POSIX标准规定，如果在字符串的某个位置存在多个可能的匹配，应当返回的是最长的匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;NFA与DFA的比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在预编译阶段（pre-use compile)的区别：在使用正则表达式搜索之前，两种引擎都会变异表达式，得到一套内化形式，适应各自的匹配算法。NFA的编译过程通常要快一些，需要的内存也更少一些。传统型NFA和POSIX NFA之间并没有实质的差别&lt;/li&gt;
&lt;li&gt;匹配速度的差别：对于“正常”情况下的简单文本匹配测试，两种引擎的速度差不多。一般来说，DFA的速度与正则表达式无关，而NFA中两者直接相关。&lt;/li&gt;
&lt;li&gt;匹配结果的差别： DFA（或则POSIX NFA）返回最左边的最长的匹配文本。传统型NFAK额能返回同样的结果，当然也可能是别的文本。&lt;/li&gt;
&lt;li&gt;能力的差异：NFA引擎能提供一些DFA不支持的功能，例如：

&lt;ol&gt;
&lt;li&gt;捕获由括号内的子表达式匹配的文本&lt;/li&gt;
&lt;li&gt;环视，以及其他复杂的零长度确认&lt;/li&gt;
&lt;li&gt;非匹配优先的量词，以及有序的多选结构&lt;/li&gt;
&lt;li&gt;占有优先量词和固化分组&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;五、正则表达式使用技巧&lt;/h2&gt;

&lt;h3&gt;正则表达式的平衡法则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;只匹配期望的文本，排除不期望的文本&lt;/li&gt;
&lt;li&gt;必须易于控制和理解&lt;/li&gt;
&lt;li&gt;如果使用NFA引擎，必须保证效率(如果能偶匹配，必须很快地返回匹配结果，如果不能匹配，应该在尽可能短的时间内报告匹配失效)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;若干简单的例子：&lt;/h3&gt;

&lt;h4&gt;匹配连续行&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    SRC= if else hello \
         very nice&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;^w+=.*(\\\n.*)*&lt;/code&gt;---&amp;gt;不能匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;^w+=[^\n\\]*(\\\n[^\n\\]*)*&lt;/code&gt;---&amp;gt; 不允许\出现在字符串中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;^w+=([^\n\\]|\\.)*&lt;/code&gt;---&amp;gt;OK&lt;/p&gt;

&lt;h4&gt;匹配IP地址&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;^\d+\.\d+\.\d+\.\d+$&lt;/code&gt; ---&amp;gt;会匹配1234.5678.12312.214214&lt;/p&gt;

&lt;p&gt;&lt;code&gt;^\d{1-3}+\.\d{1-3}+\.\d{1-3}+\.\d{1-3}+$&lt;/code&gt;或&lt;/p&gt;

&lt;p&gt;&lt;code&gt;^\d\d?\d?+\.\d\d?\d?+\.\d\d?\d?+\.\d\d?\d?+$&lt;/code&gt; ---&amp;gt;会匹配299.299.299.299等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[01]?\d\d?|2[0-4]\d|25[0-5]&lt;/code&gt; ---&amp;gt;0-255&lt;/p&gt;

&lt;p&gt;&lt;code&gt;^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;处理文件名&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将\usr\local\bin\gcc变成gcc &lt;code&gt;s/^.*\\//&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所在路径和文件名 &lt;code&gt;^(.*)/(.*)$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;匹配对称的括号&lt;/h4&gt;

&lt;p&gt;处理单层嵌套的正则表达式是：&lt;code&gt;\[^()]*(\([^()]*\)[^()]*)*\)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;匹配分隔符之间的文本&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;*(\\.|[^\\*]*&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;去除文本首尾的空白字符&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;s/^\s+//&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;s/\s+$//&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;其他&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/june_water/article/details/17101293&quot;&gt;Vim中的正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/june_water/article/details/17101633&quot;&gt;grep与正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/june_water/article/details/17102395&quot;&gt;C/C++正则表达式主要函数分析&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ gcc regex.c -o regex
$ ./regex &amp;quot;http:\/\/www\..*\.com&amp;quot; &amp;quot;https://www.taobao.com&amp;quot;
# ErrMsg: No match 
$ ./regex &amp;quot;https:\/\/www\..*\.com&amp;quot; &amp;quot;https://www.taobao.com&amp;quot;
# https://www.taobao.com matches https:\/\/www\..*\.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 
</feed>
