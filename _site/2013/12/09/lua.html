
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>Lua脚本语言学习笔记 | June's Blog</title>
    
    <meta name="description" content="">
    <meta name="author" content="June">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/images/june.png" type="image/x-icon" />
    <!-- <link rel="shortcut icon" href="/favicon.ico"> -->
  <!-- Update these with your own images
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">June's Blog</a>
          <ul class="nav">
            
            
            


  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  




            <li class="divider-vertical"></li>
            
            
            


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/about.html">About</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/atom.xml">RSS</a></li>
      	
      
    
  





            <!-- <li><a href="http://feed.zhuoqun.net/">RSS</a></li> -->
          </ul>

          <span class="pull-right slogan"> Under Linux </span>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="row post">
  <div class="span8">
    <h1 class="title">Lua脚本语言学习笔记</h1>
    <h2>开始</h2>

<p>Lua脚本是一个很轻量级的脚本，也是号称性能最高的脚本，用在很多需要性能的地方，比如：游戏脚本，nginx，wireshark的脚本。</p>

<h3>语法规范</h3>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    #注视代码块
    --[[
        print(10)
    --]]
    #取消注释
    ---[[
        print(10)
    --]]
</code></pre></div>
<h3>解释器程序</h3>

<p>lua [选项参数] [脚本[参数]]
* -e 可以直接在命令喊中输入代码，例如</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    $ lua -e &quot;print(math.sin(12))&quot;
</code></pre></div>
<ul>
<li>-l 用于加载库文件</li>
<li><p>-i 在运行完其他命令行参数后进去交互模式。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ lua -i -l a -e &quot;x=10&quot;
</code></pre></div></li>
</ul>

<p>可以定义一个名为&quot;_PROMPT&quot;的全局变量，解释器就会用它的值作为交互模式的命令提示符。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    $ lua -i -e &quot;_PROMPT=&#39;June\&#39;s lua&gt;&#39;&quot;
    ---&gt;June&#39;s lua&gt;
</code></pre></div>
<p>在交互模式中，需要打印任何表达式的值，可以用=开头，并跟随一个表达式，例如：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    June&#39;s lua&gt;=math.sin(3)
</code></pre></div>
<h2>2、类型与值</h2>

<p>Lua中有8中基础类型，函数type可根据一个值返回其类型名称</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    print(type(print))      ---&gt;function
    print(type(type(X)))    ---&gt;string
    #永远返回&quot;string&quot; 因为type函数返回一个字符串
</code></pre></div>
<ul>
<li>nil(空):全局变量第一次赋值前的默认值是nil,将nil赋予一个全局变量等于删除它</li>
<li>boolean(布尔)：true和false，Lua将值false和nil视为&quot;假&quot;，其他均为&quot;真&quot;</li>
<li>number(数字)：表示实数，双精度浮点数</li>
<li><p>string(字符串)：字符串是不可变的值，不能像C语言中那样直接修改字符串的某个字符，而是应该根据修改要求来创建一个新的字符串</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">\a:响铃
\b:退格
\f：提供表格
\n:换行
\r：回车
\t：水平tab
\v：垂直tab
\\反斜杠
\&quot;双引号
\&#39;单引号
</code></pre></div>
<p>Lua在运行时提供了数字与字符串的自动转换，如果需要显式地将一个字符串转换成数字，可以使用函数tonumber。若要将一个数字转换成字符串，可以调用函数tostring,或者将该数字与一个空字符串相连接，在Lua5.1中，可以在字符串前放置操作符&quot;#&quot;来获得该字符串的长度。</p></li>
<li><p>uerdata(自定义类型)：用于表示一种由应用程序或C语言库所创建的新类型</p></li>
<li><p>function(函数)</p></li>
<li><p>thread(线程)</p></li>
<li><p>table(表)：table.maxn函数，返回一个table的最大正索引数，当对索引的实际类型不是很确定时，可以明确地使用一个显式转换</p></li>
</ul>

<h2>3、表示式</h2>

<ul>
<li>关系操作符：对于table、userdata和函数，Lua是作引用比较的，也就是说，只有当它们引用同一个对象时，才认为它们相等。</li>
<li>逻辑操作符：对于操作符and来说，如果它的第一个操作数为假，就返回第一个操作数;不然返回第二个操作数。对于操作符or来说，如果第一个操作数为真，就返回第一个操作数；不然返回第二个操作数。and的优先级高于or</li>
<li>字符串连接：&quot;..&quot;如果任意一个操作数是数字的话，Lua会将这个数字转换成一个字符串。连接操作符智慧创建一个新的字符串，不会对原操作数进行任何修改。</li>
<li><p>优先级</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">^&gt;not # -(一元)&gt;* / %&gt;+ -&gt;..&gt;&lt; &gt; &lt;= &gt;= ~= ==&gt;and&gt;or
</code></pre></div></li>
</ul>

<h2>4、语句</h2>

<ul>
<li>多重赋值并不会比相等价的多条单一变量赋值语句更快，但有时的确会需要多重赋值，例如交换两个变量，收集函数的多个返回值。</li>
<li>局部变量和块：局部变量的作用于仅限于申明它们的那个块。一个块是一个控制结构的执行体、或者是一个函数的执行体或者是一个程序块。在交互模式中，每行输入内容自身就形成了一个程序块，可以用do-end显式地界定一个块。&quot;尽可能的使用局部变量！&quot;，访问局部变量比访问全局变量更快。&#39;local foo = foo&#39;创建一个局部变量，并将用全局变量foo的值初始化它。</li>
<li>一个申明在循环体中的局部变量的作用于包括了条件测试(5.1新功能)</li>
<li>数字型for循环中，3个表达式是在循环开始前一次性求值的，不设置循环上限:（math.huge）</li>
<li><p>泛型for循环通过一个迭代器(iterator)函数来遍历所有值，标准库提供了几种迭代器：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">io.lines:迭代文件中的每行
pairs:迭代table元素
ipairs:迭代数组元素
string.gmatch:迭代字符串中单词
</code></pre></div></li>
<li><p>数字型和泛型for循环：控制变量会被自动申明为for语句的局部变量，并且仅在循环体内可见。不要在循环过程中修改控制变量的值，否则会导致不可预知的效果。</p></li>
</ul>

<h2>5、函数</h2>

<h3>多重返回值</h3>

<ul>
<li>函数调用作为一条单独语句时，Lua会丢弃函数的所有返回值</li>
<li>函数作为表达式的一部分来调用时，Lua只保留函数的第一个返回值</li>
<li>只有当一个函数调用是一系列（多重赋值，函数调用时传入的实参列表，table的构造式和return语句）表达式中的最后一个元素时，才能获得它的所有返回值</li>
<li>可以将一个函数调用放入一对圆括号中，从而迫使它只有一个返回结果</li>
<li>unpack:接受一个数组作为参数，并从下标1开始返回该数组的所有元素，unpack的一项重要用途体现在&quot;泛型调用(generic call)&quot;机制中。泛型调用机制可以动态地以任何实参来调用任何参数。</li>
</ul>

<h3>变长参数(variable number of arguments)</h3>

<p>参数列表中的3个点表示该函数可接受不同数量的实参。</p>

<ul>
<li>string.format:格式化文本函数</li>
<li>io.write:输出文本函数</li>
<li>select：必须传入一个固定实参selector（选择开关）和一系列变长参数，如果selector为数字n，那么select返回它的第n个可变实参，否则，selector只能为字符串&quot;#&quot;,这样select会返回变长参数的总数。</li>
</ul>

<h3>具名实参</h3>

<p>将所有实参组织到一个table中，并将这个table作为唯一的实参传给函数</p>

<h2>6、深入函数</h2>

<p>函数和所有其他值一样都是匿名的，即它们都没有名称。一个函数定义实际就是一条赋值语句，这条语句创建了一种类型为”函数“的值，并将这个值赋予一个变量。</p>

<ul>
<li>table.sort:接受两个元素，并返回在有序情况下第一个元素是否应排在第二个元素前</li>
</ul>

<h3>closure（闭合函数）</h3>

<p>若将一个函数写在另一个函数之内，那么这个位于内部的函数便可以访问外部函数中的局部变量，这个特征称之为&quot;词法域&quot;。</p>

<p>closure是指一个函数及一些列这个函数会访问到&quot;非局部的变量（或upvalue)&quot;，因此若一个closure没有那些会访问的&quot;非局部变量&quot;，那它就是一个传统概念中的&quot;函数&quot;</p>

<h3>尾调用</h3>

<p>在Lua中，只有&quot;return<func>(<args>)&quot;这样的调用形式才算是一条&quot;尾调用&quot;，Lua会在调用前对<func>及其参数求值，所以它们可以是任意复杂的表达式。</p>

<h2>7、迭代器与泛型for</h2>

<h3>泛型for的语义</h3>

<p>泛型for在循环过程内部保存了迭代器函数。实际上它保存着3个值：一个迭代器函数、一个很恒定状态（invariant state）和一个控制变量（control variable）</p>

<p>泛型for的语法如下：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    for&lt;var-list&gt;in&lt;exp-list&gt;do
        &lt;body&gt;
    end
</code></pre></div>
<p>其中<code>&lt;var-list&gt;</code>是一个或多个变量的列表，以逗号分隔;<code>&lt;exp-list&gt;</code>是一个或多个表达式的列表，同样以逗号分隔。通常表达式列表只有一个元素，即一句对迭代器工厂的调用。</p>

<p>for做的第一件事情是对in后面的表达式求值。这些表达式一个返回3个值供for保存：迭代器函数、恒定状态和控制变量的初值。初始化之后，for会以恒定状态和控制变量来调用迭代器函数。然后for将迭代器函数的返回值赋予变量列表中的变量。如果第一个返回值为nil，那么循环终止</p>

<h3>无状态的迭代器</h3>

<p>一种自身不保存任何状态的迭代器，因此，我们可以在多个循环中使用同一个无状态的迭代器，比便创建新的closure开销。</p>

<h3>具有复杂状态的迭代器</h3>

<p>通常一个基于closure实现的迭代器会比一个使用table的迭代器更高效，这是因为，首先创建一个closure就比创建一个table更廉价，其次范文&quot;非局部变量&quot;比访问table字段更快。</p>

<h2>8、编译、执行与错误</h2>

<ul>
<li>loadstring总是在全局环境中编译它的字符串</li>
<li>Lua将所有独立的程序块视为一个匿名函数的函数体，并且该匿名函数还具有可变长实参。</li>
<li>assert函数检查其第一个参数是否为true，若为true，则简单返回该参数false就引发一个错误，它的第二个参数是一个可选的信息字符串。</li>
<li>pcall函数会以一种&quot;保护模式(protected mode)&quot;来调用它的第一个参数，因此pcall可以捕获函数执行中的任何错误。当pcall返回其错误信息时，它已经销毁了调用栈的部分内容，也就是从pcall到错误发生点的这部分调用。</li>
<li>xpcall：该函数除了接受一个需要被调用的函数之外，还接受第二个参数----一个错误处理函数。当发生错误时，Lua会在调用栈展开前调用错误处理函数。</li>
</ul>

<h2>9、协同程序（coroutine）</h2>

<h3>协同程序基础</h3>

<p>一个具有多个协同程序的程序在任意时刻只能运行一个协同程序，并且正在运行的协同程序只会在其显式地要求挂起（suspend)时，它的执行才会停止。</p>

<ul>
<li>在第一次调用resume时，并没有对应的yield在等待她，因此所有传递给resume的额外参数都将视为协同程序主函数的参数。在resume调用返回的内容中，第一个值为true则表示没有错误，而后面所有的值都是对应yield传入的参数。当一个协同程序结束时，它的主函数所返回的值都将作为对应resume的返回值</li>
</ul>

    <ul class="pager">
    
      <li class="previous"><a href="/2013/12/02/regex.html" title="正则表达式(regular expression)笔记">&larr; 正则表达式(regular expression)笔记</a></li>
    
    
      <li class="next"><a href="/2013/12/11/youcompleteme.html" title="Ubuntu12.04下自动补齐插件YouCompleteMe安装">Ubuntu12.04下自动补齐插件YouCompleteMe安装&rarr;</a></li>
    
    </ul>
    
  </div>
  
  <div class="span4 sidebar">
    <h4 class="date">发布日期：<span>09 December 2013</span></h4>

  
    <h4>归档</h4>
    <ul class="categories_box">
    
    


  
     
    	<li><a href="/categories.html#lua-ref">
    		lua <span>2</span>
    	</a></li>
    
  


    </ul>
    
  
  
    <h4>标签</h4>
    <ul class="tag_box">
    
    


  
     
    	<li><a href="/tags.html#lua-ref">lua <span>2</span></a></li>
    
  



    </ul>
    
  </div>
</div>


      </div>

      <footer>
        <p>&copy; <a href="mailto:junevimer@gmail.com">June</a> 2013. 
          Proudly powered by <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

