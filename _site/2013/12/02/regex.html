
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>正则表达式(regular expression)笔记 | June's Blog</title>
    
    <meta name="description" content="">
    <meta name="author" content="June">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/images/june.png" type="image/x-icon" />
    <!-- <link rel="shortcut icon" href="/favicon.ico"> -->
  <!-- Update these with your own images
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">June's Blog</a>
          <ul class="nav">
            
            
            


  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  




            <li class="divider-vertical"></li>
            
            
            


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/about.html">About</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/atom.xml">RSS</a></li>
      	
      
    
  





            <!-- <li><a href="http://feed.zhuoqun.net/">RSS</a></li> -->
          </ul>

          <span class="pull-right slogan"> Under Linux </span>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="row post">
  <div class="span8">
    <h1 class="title">正则表达式(regular expression)笔记</h1>
    <h2>一、正则表达式入门</h2>

<ul>
<li><code>^</code>代表一行的开始</li>
<li><code>$</code>代表一行的结束</li>
<li><code>.</code>匹配任意字符的字符组的简便写法，在字符组中，<code>.</code>不是元字符</li>
</ul>

<h3>字符组</h3>

<ul>
<li><code>sep[ea]r[ea]te</code>匹配seperate separate separete seperete等 </li>
<li><code>-</code>在字符组内部代表范围，H[1-6]与H[123456]一致，如果出现在字符组开头，它代表的就是一个普通字符</li>
<li><code>?</code>和<code>!</code>通常被当做元字符，挡在字符组中就不是如此</li>
</ul>

<h3>排除性字符组</h3>

<ul>
<li><code>[^1-6]</code>匹配除了1到6以外的任何字符</li>
</ul>

<h3>多选结构</h3>

<ul>
<li><code>|</code>它的意思是&quot;或&quot;，<code>Bor|Robert</code>就是能够同时匹配其中任意一个的正则表达式，在字符组中，它只是一个普通字符.</li>
<li>注意:<code>^From|Subject|Date:*</code>和<code>^（From|Subject|Date）:*</code>匹配结果是不一样的.</li>
</ul>

<h3>忽略大小写</h3>
<div class="highlight"><pre><code class="text language-text" data-lang="text">egrep的命令行参数&quot;-i&quot;表示进行忽略大小写的匹配，写在正则表达式之前.
</code></pre></div>
<h3>单词分界符</h3>

<p>前提:egrep支持”元字符序列“</p>

<ul>
<li><code>\&lt;</code>和<code>\&gt;</code>用来匹配单词分界的位置。<code>\&lt;cat\&gt;</code>匹配cat这个单词.<code>\&lt;cat</code><code>cat\&gt;</code>用来匹配以cat开头和结束的单词.<code>&lt;</code><code>&gt;</code>本身不是元字符，只有当它们和斜线结合起来的时候。整个序列才具有特殊意义，所以称之为元字符序列.</li>
</ul>

<h3>可选项元素</h3>

<ul>
<li><code>?</code> 代表可选项.把它加在一个字符的后面，就表示此处容许出现这个字符，不过它的出现并非匹配成功的必要条件</li>
</ul>

<h3>其他量词：重复出现</h3>

<ul>
<li><code>+</code>表示之前紧邻的元素出现一次或多次，</li>
<li><code>*</code>表示之前紧邻的元素出现任意多次，或者不出现.</li>
</ul>

<h3>规定重现次数的范围：区间</h3>

<ul>
<li>某些本版本的egrep能够使用元字符序列来自定义出现次数的区间：<code>[a-zA-z]{1,5}</code>来匹配1到5个字母</li>
</ul>

<h3>括号及反向引用</h3>

<p>括号的两种用途：限制多选项的范围;将若干字符组合为一个单元，受问号或星号之类量词的作用。
反向引用例子：<code>\&lt;([a-z]+)+\1\&gt;</code>用来查找连续的重复单词，但egrep吧每行文字都当做一个独立部分来看待，所以如果两个单词在不同行，这个表达式就无法找到.</p>

<h3>神奇的转义</h3>

<ul>
<li><code>\</code> 作用的元字符会失去特殊意义，成了普通字符</li>
</ul>

<h3>Note:</h3>

<ul>
<li>egrep会在检查正则表达式之前把每一行的换行符去掉</li>
<li>在字符组内部，元字符的定义规则以及它们的意义是不一样的</li>
<li>无论列出的字符有多少，字符组只能匹配一个字符。相反，多选项可以匹配任意长度的文本，每个多选项可能匹配的文本都是独立的，多选项没有像字符数组那样的排除功能</li>
<li>排除性子附注是表示所有未列出的字符组的简便方法,因此，<code>[^x]</code>的意思不是”只有当这个位置不是x时才能匹配“，而是说”匹配一个不等于x的字符&quot;</li>
<li>大多数程序设计语言和工具都支持字符数组内部的转义，但是大多数版本的egrep不支持，它们会把反斜线当做字符组内部列出的普通字符</li>
</ul>

<h3>更多的列子</h3>

<ul>
<li>匹配时间：<code>(1[012]|[1-9]):[0-5][0-9](am|pm)</code>或<code>[01]?[0-9]|2[0-3]:[0-5][0-9]</code></li>
</ul>

<h2>二、入门示例扩展</h2>

<ul>
<li>在尝试匹配时，正则表达式中的元字符<code>\1</code>指向之前匹配的某些文本，匹配成功之后，在接下来的程序中用<code>$1</code>来引用同样的文本</li>
<li>非捕获型括号<code>(?:...)</code>表示只分组，不捕获</li>
</ul>

<h3>许多流派的正则表达式提供的简记法</h3>

<ul>
<li><code>\b</code> 在perl中，匹配一个单词的分界符，但是在字符组中，它匹配一个退格符</li>
<li><code>\t</code> 制表符</li>
<li><code>\n</code> 换行符</li>
<li><code>\r</code> 回车符</li>
<li><code>\s</code> 任何“空白”的字符(例如空格符、制表符等)</li>
<li><code>\S</code> 除<code>\s</code>以外的任何字符</li>
<li><code>\w</code> <code>[a-z0-9A-Z]</code>(在<code>\w+</code>中很有用，可以用来匹配一个单词)</li>
<li><code>\W</code> 除<code>\w</code>之外的任何字符，也就是<code>[^a-zA-Z0-9]</code></li>
<li><code>\d</code> <code>[0-9]</code>，即数字</li>
<li><code>\D</code> 除<code>\d</code>外的任何字符，即<code>[^0-9]</code></li>
</ul>

<h3>使用正则表达式修改文本</h3>

<ul>
<li><code>s/.../.../*</code>将前面的字符串内容替换为后面的字符串内容。</li>
<li><code>s/.../.../g</code> <code>/g</code>表示全局替换，它告诉<code>s/.../.../</code>在第一次替换完成之后继续搜索更多的匹配文本，进行更多的替换.</li>
<li><code>s/\bJeff\b/Jeff/i</code>搜索&quot;Jeff&quot;这个词是不区分大小写的。而所有匹配的字符串都会被替换为&quot;Jeff&quot;，第一个字母是大写，其他为小写.<code>/i</code>对replacement的文本没有影响</li>
<li><code>s/(\.\d\d[1-9]?)\d*/$1/</code>保留小数点后梁如数字，如果第三位不为0,也需要保留</li>
<li><code>/^\s*$/</code>检测空格行</li>
<li><code>/^Subject:(.*)/i</code>不区分大小写匹配Subject，将之后的内容捕获</li>
<li><code>\S+</code>匹配第一个空白之前的文本（或者目标文本末尾之前的所有字符）</li>
<li><code>s/^/|&gt;/</code>在开头加入<code>|&gt;</code></li>
</ul>

<h3>用环视功能为数值添加逗号</h3>

<p>环视结构不匹配任何字符，只匹配文本中的特定位置，环视不会占用字符</p>

<ul>
<li>顺序环视：顺序环视顺序（从左到右）查看文本，尝试匹配子表达式，如果能够匹配，就返回匹配成功信息。</li>
<li><code>(?=...)</code>:肯定顺序环视</li>
<li><code>(?!...)</code>:否定顺序环视</li>
<li>逆序环视：它逆序（从右到左）查看文本</li>
<li><code>(?&lt;=...)</code>:肯定逆序环视</li>
<li><code>(?&lt;!...)</code>:否定逆序环视</li>
</ul>

<h4>顺序环视示例</h4>

<ul>
<li><code>(?=Jeffey)Jeff</code>它只能匹配&quot;Jerrfrey&quot;这个单词中的&quot;Jeff&quot;，它与<code>Jeff(?=rey)</code>等价</li>
<li><code>s/\bJeff(?=s\b)/Jeff&#39;/g</code></li>
<li><code>s/(?&lt;=\bJeff)(?=s\b)/&#39;/g</code>匹配了我们希望插入撇号的位置。在这种情况下，我们并没有“替换”任何字符，而只是插入了一个撇号。且与<code>s/(?=s\b)(?&lt;=\bJeff)/&#39;/g</code>等价。无论是先检查左边，再检查右边，还是相反，关键是，在同一位置两边的检测必须都能成功，整个匹配才算成功。</li>
<li><code>s/(?&lt;=\d)(?=(\d\d\d)+$</code>/,/g 在2238748274数字中每隔3个数字加入&quot;,&quot;即2,238,748,274，PS:若不捕获，可以用<code>(?:\d\d\d)</code>
*<code>(?&lt;!\w)(?=\w)</code> 表示单词起始分界符
*<code>(?&lt;=\w)(?!\w)</code> 表示单词结束分界符</li>
<li><code>s/(\d)(?=(\d\d\d)+(?!\d)/$1,/g</code>不通过你逆序环视添加逗号</li>
</ul>

<h4>Note</h4>

<p>一次迭代完成时，下一次的迭代会从上一次匹配的终点开始尝试。使用环视的意义在于，检查某个位置，但检查时匹配的字符并不算在（最终）“匹配的字符串”内。</p>

<h2>三、正则表达式的特性和流派概览</h2>

<p>在某种特定的宿主语言或工具软件中使用正则表达式时，主要有三个问题值得注意：</p>

<ul>
<li>支持的元字符，以及这些元字符的意义。这通常成为正则表达式的“流派(flavor)”</li>
<li>正则表达式与语言或工具的“交互”(interface)方式。譬如如何进行正则表达式操作，容许进行哪些操作，以及这些操作的目标文本类型。</li>
<li>正则表达式引擎如何将表达式应用到文本。语言或工具的设计者实现正则表达式的方法，对正则表达式能够取得的结果有重要的影响。</li>
</ul>

<p>一般来说，程序设计语言有3中处理正则表达式的方式：级城市(integrated)、程序是(procedural)和面向对象式(object-oriented)。在第一种方式中，正则表达式是直接内建在语言中的，Perl就是如此。但是在其他两种方式中，正则表达式不属于语言的低级语法。相反，普通的函数接受普通的字符串，把它们作为正则表达式进行处理。由不太能够的函数进行不通的、关系到一个或多个正则表达式的操作。大多数语言（不包括perl)采用的都是这两种方式之一，包括Java、.NET、Tcl、Python、PHP、Emacs、lisp和Ruby。</p>

<h3>正则模式和匹配模式</h3>

<ul>
<li>不区分大小写的匹配模式 i</li>
<li>宽松排列和注释模式：忽略字符组外部的所有空白字符 x</li>
<li>点号通配模式(dot-match-all match mode，也叫&quot;单行模式&quot;) s</li>
<li>增强的行锚点模式(Enhanced line-anchor match mode,也叫&quot;多行文本模式&quot;) m</li>
<li>文字文本模式：文字文本模式几乎不能识别任何正则表达式元字符</li>
</ul>

<h3>常见的元字符和特性</h3>

<h4>字符表示法：</h4>

<ul>
<li><code>\a</code> 警报</li>
<li><code>\e</code> Escape字符,通常对应ASCII中的<code>&lt;ESC&gt;</code>字符</li>
<li><code>\v</code> 垂直制表符</li>
</ul>

<h4>八进制转义\num</h4>

<p>支持八进制转义方式通常容许以2到3位数字表示该值所代表的字节或字符。八进制转义可以很方便地在正则表达式中插入平时难以输入的字符</p>

<h4>十六进制及Unicode转义:\xnum、\x{num}、\unum、\Unum</h4>

<h4>几乎能匹配任何字符的元字符：点号</h4>

<p>在某些工具软件中，点号用来缩略表示可以匹配任何字符的字符组，而在其他工具中，点号能匹配除了换行符之外的任何字符，关于点号，需要注意的有：
* 匹配模式会改变点号的匹配规则
* POSIX规定，点号不能匹配NULL（值为0的字符），尽管大多数脚本语言容许文本中出现NULL（而且可以用点号来匹配）</p>

<h4>POSIX&quot;字符组&quot;方括号表示法</h4>

<p>我们通常所说的字符组，在POSIX标准中成为方括号表达式(bracket expression)。POSIX中的属于“字符组”指的是在方括号表达式内部使用的一种特殊功能。</p>

<p>POSIX字符组的详细列表根据locale的变化而变化，但是下面这些通常都能支持：</p>

<ul>
<li><code>[:alnum:]</code> 字母字符和数字字符</li>
<li><code>[:alpha:]</code> 字母</li>
<li><code>[:blank:]</code> 空格和制表符</li>
<li><code>[:cntrl:]</code> 控制字符</li>
<li><code>[:digit:]</code> 数字</li>
<li><code>[:graph:]</code> 非空字符（即空白字符，控制字符之外的字符）</li>
<li><code>[:lower:]</code> 小写字母</li>
<li><code>[:print:]</code> 类似<code>[:graph:]</code>,但是包含空白字符</li>
<li><code>[:punct:]</code> 标点符号</li>
<li><code>[:space:]</code> 所有的空白字符（<code>[:blank:]</code>、换行符、回车符及其他）</li>
<li><code>[:upper:]</code> 大写字母</li>
<li><code>[:xdigit:]</code> 十六进制中容许出现的数字（例如0-9a-fA-F）</li>
</ul>

<h4>锚点及其他“零长度断言”</h4>

<ul>
<li>行/字符串的其实位置<code>^</code>、<code>\A</code> 脱字符<code>^</code>匹配需要搜索的文本的起始位置，如果使用了增强的行锚点匹配模式，它还能匹配每个换行符之后的位置。如果可以使用，则无论在什么匹配模式下，<code>\A</code>总是能够匹配待搜索文本的起始位置。</li>
<li>行/字符串的结束位置：<code>$</code>、<code>\z</code>和<code>\Z</code>.<code>$</code>最常见的意思是匹配目标字符串的末尾，也可以匹配整个字符串末尾的换行符之前的位置。匹配模式可以改变<code>$</code>的意义，匹配字符串中的任何换行符。如果支持，<code>\Z</code>通常表示“未指定任何模式下”<code>$</code>匹配的字符，通常是字符串的末尾位置，或者是在字符串末尾的换行符之前的位置。作为补充，<code>\z</code>只匹配字符串的末尾，而不考虑任何换行符</li>
<li>匹配的起始位置（或者是上一次匹配的结束位置）：<code>\G</code></li>
<li>环视:环视结构中，大多数实现方式都限制了逆序环视中的表达式的长度（但是顺序环视则没有限制），在Perl和Python中。逆序环视只能匹配固定长度的文本。</li>
</ul>

<h3>注释和模式修饰符</h3>

<h4>模式修饰符：（?modifier),例如(?i)和(?-i)</h4>

<p><code>(?i)</code> 启用不区分大小写的匹配，而<code>(?-i)</code>会停用此功能。例<code>&lt;B&gt;(?i)very(?-i)&lt;/B&gt;</code>。除Python之外。大多数实现方式中，<code>(?i)</code>的作用范围都只限于括号内部（也就是说，在闭括号之后就失效），即<code>&lt;B&gt;(?:(?i)very)&lt;/B&gt;</code></p>

<h4>模式作用范围：(?modifier:...)，例如(?i:...)</h4>

<p><code>(?i:...)</code>表示模式修饰符的作用范围只有在括号内有效。</p>

<h4>注释：(?#...)和#...</h4>

<h4>文字文本范围:\Q...\E</h4>

<p>它会消除其中除了\E之外所有元字符的特殊含义（如果没有\E，就会一直作用到正则表达式末端）。其中的所有字符都会被当成普通文字文本来对待。如果在构建正则表达式时包含变量，次功能就非常有用。</p>

<h3>分组，捕获，条件判断和控制</h3>

<h4>捕获/分组括号：(...)和\1，\2，...</h4>

<p>捕获型括号的编号是按开括号出现的次序，从左到右计算的。如果提供了反向引用，则这些括号内的子表达式匹配的文本可以在表达式的后面部分用<code>\1</code>、<code>\2</code>来引用。</p>

<h4>仅用于分组的括号：<code>(?:...)</code></h4>

<p>仅用于分组的括号<code>(?:...)</code>不能用来提取文本，而只能用来规定多选结构或者两次的作用对象。</p>

<h4>命名捕获：(?<name>...)</h4>

<h4>固化分组：(?&gt;...)</h4>

<p>一旦括号内的子表达式匹配之后，匹配的内容就固定下来（固化(atomic)下来无法改变），在接下来的匹配过程中不会变化，除非整个固化分组的括号都被弃用，在外部回溯中重新应用。</p>

<h4>多选结构：...|...|...</h4>

<p>多选结构的优先级很低，所以<code>this and|or that</code>的匹配等价于<code>(this and)|(or that)</code></p>

<h4>条件判断：(?if then |else)</h4>

<h2>四、表达式的匹配原理</h2>

<p>正则引擎可以粗略地分为3类：</p>

<ul>
<li>DFA(符合或不符合POSIX标准的都属于此类）</li>
<li>传统型NFA</li>
<li>POSIX NFA</li>
</ul>

<h3>匹配的基础</h3>

<ul>
<li>优先选择最左端的匹配结果，如用<code>fat|cat|belly|your</code>来匹配字符串<code>The dragging belly indicates that your cat is too fat</code>的结果是<code>beely</code></li>
<li>标准的匹配量词(<code>*</code>、<code>+</code>、<code>?</code>)和<code>{m,n}</code>是匹配优先的。</li>
</ul>

<h3>引擎构造</h3>

<p>正则引擎中的零件分为几类————文字字符(literal characters)、量词（qualifiers）、字符组（character classes）、括号，等等。</p>

<p>锚点可以分为两类：简单锚点（^、$、\G、\b、）和复杂锚点(例如顺序环视和逆序环视）。简单锚点之所以得名，就在于它们只是检查目标字符串中的特定位置的情况，或者是比较两个相邻的字符。相反，复杂锚点能包含任意复杂的子表达式，所以它们也可以任意复杂。</p>

<h3>表达式主导与文本主导</h3>

<ul>
<li>NFA引擎：表达式主导</li>
<li>DFA引擎：文本主导</li>
</ul>

<h3>比较NFA与DFA</h3>

<p>DFA特性:</p>

<ul>
<li>DFA匹配很迅速</li>
<li>DFA匹配很一致</li>
<li>谈论DFA匹配很恼人</li>
</ul>

<h4>回溯</h4>

<p>NFA引擎最重要的性质是，它会依次处理各个子表达式或组成元素，遇到需要在两个可能成功的可能中进行选择的时候，它会选择其一，同时记住另一个，以备稍后可能的需要。</p>

<p>回溯的两个要点：</p>

<ul>
<li><p>如果需要在“进行尝试”和“跳过尝试”之间选择，对于匹配优先量词，引擎会优先选择“进行尝试”，而对于忽略优先量词，会选择“跳过尝试”。</p></li>
<li><p>距离当前最近存储的选项就是当本地失败强制回溯时返回的。使用的原则是LIFO（last in first out,后进先出）。</p></li>
</ul>

<h4>匹配优先</h4>

<p>匹配时只从自身出发，匹配尽可能多的内容，只有在全局匹配需要的情况下才会“被迫”交换一些字符。</p>

<h4>忽略匹配优先</h4>

<p>与匹配优先相反</p>

<h3>占有优先量词和固化分组</h3>

<ul>
<li>用(?&gt;...)实现固化分组：如果匹配进行到此结构之后（也就是，进行到闭括号之后），那么此结构体中的所有备用状态都会被放弃。也就是说，在固化分组匹配结束时，它已经匹配的文本已经固化为一个单元，只能作为整体而保留或放弃。</li>
</ul>

<h3>Note</h3>

<p>匹配优先和忽略优先都不会影响需要检测路径的本身，而智慧影响检测的顺序。如果不能匹配，无论是按照匹配优先还是忽略优先的顺序，最终每条路径都会被测试。然而，固化分组与它们截然不同，因为固化分组会放弃某些可能的路径。更具具体情况的不同，放弃备用状态可能会导致不同的结果：
* 毫无影响
* 导致匹配失败
* 改变匹配结果
* 加快报告匹配失败的速度</p>

<h3>占用优先量词，<code>?+</code>、<code>*+</code>、<code>++</code>和<code>{m,n}+</code></h3>

<p>占用优先量词与匹配优先量词很相似，只是它们从来不交还已经匹配的字符。</p>

<h3>环视中的回溯</h3>

<p>只要环视结构的匹配尝试结束。它就不会留下任何备用状态。任何备用状态和例子中肯定环视成功时的情况一样，都会被放弃。</p>

<h3>多选结构</h3>

<p>传统型NFA引擎，遇到多选结构时，这种引擎会按照从左到右的顺序检查表达式中的多选分支，NFA和POSIX NFA中有匹配优先的多选结构，它们总是匹配所有多选分支中能匹配最多文本的那个。</p>

<h3>NFA、DFA和POSIX</h3>

<ul>
<li>最左最长规则：如果传动装置在文本的某个特定位置启动DFA引擎，而在此位置又有一个或多个可能的匹配，DFA就会选择这些可能中最长的</li>
<li>POSIX和最左最长规则：POSIX标准规定，如果在字符串的某个位置存在多个可能的匹配，应当返回的是最长的匹配。</li>
</ul>

<h3>NFA与DFA的比较</h3>

<ul>
<li>在预编译阶段（pre-use compile)的区别：在使用正则表达式搜索之前，两种引擎都会变异表达式，得到一套内化形式，适应各自的匹配算法。NFA的编译过程通常要快一些，需要的内存也更少一些。传统型NFA和POSIX NFA之间并没有实质的差别</li>
<li>匹配速度的差别：对于“正常”情况下的简单文本匹配测试，两种引擎的速度差不多。一般来说，DFA的速度与正则表达式无关，而NFA中两者直接相关。</li>
<li>匹配结果的差别： DFA（或则POSIX NFA）返回最左边的最长的匹配文本。传统型NFAK额能返回同样的结果，当然也可能是别的文本。</li>
<li>能力的差异：NFA引擎能提供一些DFA不支持的功能，例如：

<ol>
<li>捕获由括号内的子表达式匹配的文本</li>
<li>环视，以及其他复杂的零长度确认</li>
<li>非匹配优先的量词，以及有序的多选结构</li>
<li>占有优先量词和固化分组</li>
</ol></li>
</ul>

<h2>五、正则表达式使用技巧</h2>

<h3>正则表达式的平衡法则</h3>

<ul>
<li>只匹配期望的文本，排除不期望的文本</li>
<li>必须易于控制和理解</li>
<li>如果使用NFA引擎，必须保证效率(如果能偶匹配，必须很快地返回匹配结果，如果不能匹配，应该在尽可能短的时间内报告匹配失效)。</li>
</ul>

<h3>若干简单的例子：</h3>

<h4>匹配连续行</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    SRC= if else hello \
         very nice&quot; 
</code></pre></div>
<p><code>^w+=.*(\\\n.*)*</code>---&gt;不能匹配</p>

<p><code>^w+=[^\n\\]*(\\\n[^\n\\]*)*</code>---&gt; 不允许\出现在字符串中</p>

<p><code>^w+=([^\n\\]|\\.)*</code>---&gt;OK</p>

<h4>匹配IP地址</h4>

<p><code>^\d+\.\d+\.\d+\.\d+$</code> ---&gt;会匹配1234.5678.12312.214214</p>

<p><code>^\d{1-3}+\.\d{1-3}+\.\d{1-3}+\.\d{1-3}+$</code>或</p>

<p><code>^\d\d?\d?+\.\d\d?\d?+\.\d\d?\d?+\.\d\d?\d?+$</code> ---&gt;会匹配299.299.299.299等</p>

<p><code>[01]?\d\d?|2[0-4]\d|25[0-5]</code> ---&gt;0-255</p>

<p><code>^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$</code></p>

<h4>处理文件名</h4>

<ul>
<li>将\usr\local\bin\gcc变成gcc <code>s/^.*\\//</code></li>
<li>所在路径和文件名 <code>^(.*)/(.*)$</code></li>
</ul>

<h4>匹配对称的括号</h4>

<p>处理单层嵌套的正则表达式是：<code>\[^()]*(\([^()]*\)[^()]*)*\)</code></p>

<h4>匹配分隔符之间的文本</h4>

<p><code>*(\\.|[^\\*]*&quot;</code></p>

<h4>去除文本首尾的空白字符</h4>

<p><code>s/^\s+//</code></p>

<p><code>s/\s+$//</code></p>

<h2>其他</h2>

<ul>
<li><a href="http://blog.csdn.net/june_water/article/details/17101293">Vim中的正则表达式</a></li>
<li><a href="http://blog.csdn.net/june_water/article/details/17101633">grep与正则表达式</a></li>
<li><p><a href="http://blog.csdn.net/june_water/article/details/17102395">C/C++正则表达式主要函数分析</a></p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ gcc regex.c -o regex
$ ./regex &quot;http:\/\/www\..*\.com&quot; &quot;https://www.taobao.com&quot;
# ErrMsg: No match 
$ ./regex &quot;https:\/\/www\..*\.com&quot; &quot;https://www.taobao.com&quot;
# https://www.taobao.com matches https:\/\/www\..*\.com
</code></pre></div></li>
</ul>

    <ul class="pager">
    
    
      <li class="next"><a href="/2013/12/09/lua.html" title="Lua脚本语言学习笔记">Lua脚本语言学习笔记&rarr;</a></li>
    
    </ul>
    
  </div>
  
  <div class="span4 sidebar">
    <h4 class="date">发布日期：<span>02 December 2013</span></h4>

  
    <h4>归档</h4>
    <ul class="categories_box">
    
    


  
     
    	<li><a href="/categories.html#regex-ref">
    		regex <span>1</span>
    	</a></li>
    
  


    </ul>
    
  
  
    <h4>标签</h4>
    <ul class="tag_box">
    
    


  
     
    	<li><a href="/tags.html#regex-ref">regex <span>1</span></a></li>
    
  



    </ul>
    
  </div>
</div>


      </div>

      <footer>
        <p>&copy; <a href="mailto:junevimer@gmail.com">June</a> 2013. 
          Proudly powered by <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

